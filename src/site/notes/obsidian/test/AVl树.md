---
{"dg-publish":true,"permalink":"/obsidian/test/a-vl/","created":"2024-09-08T15:30:13.859+08:00","updated":"2024-09-08T16:03:27.243+08:00"}
---

# 摊还分析
作用：
	分析数据结构上操作的平均时间复杂度。即使单个操作在最坏情况下可能很慢，但在一系列操作中，这些操作的平均性能往往表现得更好。

主要思想
	衡量操作在长期内的代价，平摊到每次操作上。它有三种常见的分析方法：**聚合法、计账法（又称合算法）、势能法**


>[!star]-
>1. 分析时间复杂度针对的是一个具体的操作；
>2.  而摊还分析的对象是一个数据结构的一系列操作，包含成本较低与较高的不同操作，与概率无关

### 1. **聚合法（Aggregate Method）**

聚合法是一种最直接的摊还分析方法。它通过分析一系列操作的总成本，然后通过总操作次数平均下来，得到每次操作的平均成本。该方法的主要思想是计算整个序列的所有操作的总成本 \( T(n) \)，再除以操作次数 \( n \)，从而得出摊还的平均成本 \( T(n) / n \)。

#### 举例说明：
假设我们有一个动态数组，它每当满时就需要扩容（如将容量翻倍）。在最坏情况下，插入元素的成本是 \( O(n) \)，因为我们需要复制整个数组，但通过聚合法，我们可以看到大部分操作是常数时间 \( O(1) \) 的。

1. 当数组容量为 1 时，插入一个元素需要常数时间 \( O(1) \)；
2. 容量翻倍时，我们需要将数组的所有元素复制到新数组中，这种复制操作在一些插入操作上发生；
3. 对于一系列的 \( n \) 次插入操作，总的复制次数为 \( 1 + 2 + 4 + \dots + n/2 = O(n) \)。

因此，通过聚合法，所有插入操作的总成本是 \( O(n) \)，而每次操作的摊还成本是 \( O(1) \)。

```ad-tip
适用于对简单和复杂操作的时间复杂度都方便计算的情形
>通过数学方式计算M步操作的时间总和，再除以M
```
### 2. **计账法（Banker's Method / Accounting Method）**
计账法通过为每个操作“预付”一定的费用，来保证整个操作序列中的每个操作都有足够的费用支付最坏情况下的操作代价。每次操作的费用可以分为两部分：
- **实际成本**：每次操作需要立即支付的成本。
- **预付成本（Credit）**：为未来可能需要花费的昂贵操作预留的成本。

在计账法中，简单操作支付的费用通常会高于它们的实际成本，这样多余的费用（存入“信用”）可以用来支付后续复杂操作的高昂成本。

```ad-info
需要具有一定的抽象思维：
>考虑对简单的操作到底收取多少的费用
```
### 举例说明：
继续以动态数组为例，假设我们为每次插入操作支付 \( 3 \) 单位的费用：
1. 对于大多数插入操作，实际成本是 \( 1 \) 单位，因此我们会剩下 \( 2 \) 单位的费用；
2. 当需要扩容时，复制操作的实际成本是 \( n \)，但我们之前通过多次简单操作积累了足够的“信用”来支付扩容的代价。

通过这种方法，我们可以保证每次插入操作的摊还成本是常数 \( O(1) \)。

### 3. **势能法（Potential Method）**

势能法是一种更为数学化的摊还分析方法，它通过定义一种“势能函数”来表示数据结构的潜在状态，这种势能类似于系统的能量。势能函数的值会随着数据结构的变化而增加或减少。势能法的核心思想是：
- 当执行较廉价的操作时，势能增加；
- 当执行昂贵的操作时，势能减少，从而抵消一部分代价。

```ad-star
**让消耗大的那一步操作势能大大的降！**
>以此为势能函数的设计理念
```


### **综上所述**：
- **聚合法**：通过计算一系列操作的总成本并平均分摊到每个操作上，来得出摊还成本。
- **计账法**：通过为每次操作设定一个固定的“预付”费用，将多余的费用存储起来以支付将来可能出现的高成本操作。
- **势能法**：通过定义势能函数衡量数据结构的潜在状态，分析每次操作前后势能的变化，推导出摊还成本。

这些方法在摊还分析中的应用各有侧重，但都能用于分析数据结构的操作复杂度。在高级数据结构中，它们被广泛用于分析例如堆、斐波那契堆、哈希表、动态数组等数据结构的操作效率。

# AVL树的旋转

- 原因：执行插入操作时可能导致AVL的一方偏重，需要进行调整
- 策略：同向偏重对其子树进行反向的旋转，异向偏重执行两次不同的旋转
>https://www.cs.usfca.edu/~galles/visualization/AVLtree.html 可视化

```ad-example
左子树偏重（BF=-2）的情况为例（右子树偏重对称）：

-左子树继续偏重，对左子树右旋
-右子树偏重，先对右子树进行左旋，在对结果的左子树进行右旋
```

```ad-tip
x旋可以理解为重心向x方向移动
```
```ad-star
平衡因子BF = 右子树-左子树的高度！
```

## 伪代码实现
🌰：
```c
Maintain-Balanced (p)
	if h[ls[p]] - h[rs[p]] == 2
		if h[ls[ls[p]]] >= h[rs[ls[p]]] 
			Right-Rotate (p) 
		else 
			Left-Rotate (ls[p])
			Right-Rotate(p)
	else if h[ls[p]] - h[rs[p]] == -2
		if h[ls[rs[p]]] <= h[rs[rs[p]]]
			Left-Rotate (p)
		else
			Right-Rotate(rs[p])
			Left-Rotate(p)
```

## **换根视角**
### LL Single Rotation
将偏重所在的子树作为根R'，然后将原先的根节点R作为其子节点；
原来的根节点空缺左子树则取R'的右孩子连接；否则取R‘的左孩子连接

### LR & RL
1. 找到三个关键节点
2. 将最下方的节点上浮作为根节点R
3. 剩下的两个节点A、B分别作为R的左右子树
4. 由于经过步骤②会使得节点A、B共空缺左右孩子分别一个，因此需要将R原先的左右孩子作为A、B的左右孩子

```ad-quote
https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/Lec01/#%E6%8D%A2%E6%A0%B9%E8%A7%86%E8%A7%92
```

---
# Splay 树
- 定义：
	伸展树，希望在摊还复杂度 `log N`的情况下完成大部分对点操作

```ad-tip
与AVL树还有什么区别？
>Splay不再维护AVL树的平衡特性，只是希望尽可能地平衡
```

对点操作的流程：将目标点移到根部（不断旋转整个树的构造）

- **操作分类**
	zig:
	zig-zig
	zig-zag

```ad-quote
修佬对于Splay对点操作的摊还复杂度证明
>https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/Lec01/#%E6%91%8A%E8%BF%98%E5%88%86%E6%9E%90
```
