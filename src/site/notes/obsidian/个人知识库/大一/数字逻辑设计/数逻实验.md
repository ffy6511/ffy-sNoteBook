---
{"dg-publish":true,"permalink":"/obsidian/////","created":"2024-04-10T16:37:36.233+08:00","updated":"2024-09-08T15:25:05.428+08:00"}
---

- fttp:
> ftp://10.78.18.205/
# 基本操作
## Logisim的使用
### 导出为Verilog
>通过 Logisim 电路原理图导出 Verilog 的方法
https://guahao31.github.io/2024_DD/warmup/lab4/#logisim-export-verilog
### 流程
1. 绘图
2. 对电路图进行**仿真**，记录仿真结果
3. 将绘制的电路图导出为Verilog
## Vivado的基本操作
>https://guahao31.github.io/2024_DD/warmup/lab4/#vivado
>xc7k160tffg676-2L
### 改变运行总时间
1. 右键simulation
2. settings当中可以看到并修改运行总时间
# 实验
>project5--动手做
>desk--lab5--3-8 译码器
>D_---楼道灯
## 实验5
### 3-8

### 楼道灯
- 约束文件
``` verilog
set_property IOSTANDARD LVCMOS15 [get_ports S1]
set_property PACKAGE_PIN AA10 [get_ports S1]

set_property IOSTANDARD LVCMOS15 [get_ports S2]
set_property PACKAGE_PIN AB10 [get_ports S2]

set_property IOSTANDARD LVCMOS15 [get_ports S3]
set_property PACKAGE_PIN AA13 [get_ports S3]

set_property IOSTANDARD LVCMOS33 [get_ports P]
set_property PACKAGE_PIN AF24 [get_ports P]
```
- 仿真文件
```verilog
`timescale 1ns / 1ps

module LampCtrl138_tb();

reg S1;
reg S2;
reg S3;
wire P;
integer i;
lamp LampCtl138(P,S1,S2,S3);
initial begin
   for(i=0;i<=8;i=i+1) begin 
    {S3,S2,S1}=i;#100;
    end
   end
endmodule
```
### 验证
引导约束
```verilog
`timescale 1ns / 1ps

//////////////////////////////////////////////////////////////////////////////////
module D_74LS138_TB();
  reg A;
  reg B;
  reg C;
  reg G;
  reg G2A;
  reg G2B;
  wire [7:0] Y;
  D_74LS138 u1(A, B, C, G, G2A, G2B, Y);
  integer i;
	initial begin
		C = 0;
		B = 0;
		A = 0;	
		G = 1;
		G2A = 0;
		G2B = 0;
		#50;
	
for (i=0; i<=7;i=i+1) begin
	{C,B,A} = i;
		#50;
    end
    
    assign G = 0;
		assign G2A = 0;
		assign G2B = 0;
		#50;
	
for (i=0; i<=7;i=i+1) begin
	{C,B,A} = i;
		#50;
    end
		
		assign G = 1;
		assign G2A = 1;
		assign G2B = 0;
		#50;

for (i=0; i<=7;i=i+1) begin
	{C,B,A} = i;
		#50;
    end

		assign G = 1;
		assign G2A = 0;
		assign G2B = 1;
		#50;		

for (i=0; i<=7;i=i+1) begin
	{C,B,A} = i;
		#50;
    end
    
    end
endmodule

```
## lab6
### 步骤一
1. ![Pasted image 20240412222412.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240412222412.png)
2. 代码：
```verilog
`timescale 1ns / 1ps

module MyMC14495_tb();

// Inputs
reg D0;
reg D1;
reg D2;
reg D3;
reg LE;
reg point;

// Output
wire p;
wire a;
wire b;
wire c;
wire d;
wire e;
wire f;
wire g;

// Instantiate the UUT
MyMC14495 MC14495_inst (
.D0(D0), 
.D1(D1), 
.D2(D2), 
.D3(D3), 
.LE(LE), 
.point(point), 
.p(p), 
.a(a), 
.b(b), 
.c(c), 
.d(d), 
.e(e), 
.f(f), 
.g(g)
);

    integer i;
initial begin
	D3 = 0;
	D2 = 0;
	D1 = 0;
	D0 = 0;
	LE = 0;
	point = 0;
	for (i=0; i<=15;i=i+1) begin
		#50;
		{D3,D2,D1,D0}=i;
		point = i;
	end
		
	#50;
	LE = 1;
end
endmodule

```
3. logisim![Pasted image 20240412222709.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240412222709.png)

output--wire;
input--reg

### 步骤二
1. logisim![Pasted image 20240412224514.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240412224514.png)
2. 仿真![Pasted image 20240414202942.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240414202942.png)
3. 仿真代码
```verilog
`timescale 1ns / 1ps

module DispNum_testbench;

  // Inputs
  reg [1:0] BTN;
  reg [7:0] SW;

  // Outputs
  wire [3:0] AN;
  wire BTN_X;
  wire [7:0] SEGMENT;

  // Instantiate the Unit Under Test (UUT)
  DispNum uut (
    .AN(AN),
    .BTN(BTN),
    .BTN_X(BTN_X),
    .SEGMENT(SEGMENT),
    .SW(SW)
  );

  // Variables for the test
  integer i;

  initial begin
    // Initialize Inputs
    BTN = 2'b00;  // Assuming LE is the LSB of BTN
    SW = 8'b11111111;  // AN signals are SW[7:4], so we'll start with them set to 0

    // Wait for global reset
    #100;

    // Now we will cycle through all possible combinations for D0 to D3
    for (i = 0; i < 16; i = i + 1) begin
      // Set D0 to D3 (SW[0] to SW[3])
      SW[3:0] = i;

      // Set LE and point
      BTN[0] = 0;  // LE is 0
      SW[7] = 1;   // point is 1, keeping AN as 0

      // Wait 100 ns for changes to settle
      #100;
    end

    // Finish the simulation
    #100;
  end

endmodule

```
4. 测试图片
		![844b52b6e4f40460b04b0e52ce687ea 1.jpg](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/844b52b6e4f40460b04b0e52ce687ea%201.jpg)
		![9d70b70908579fd0f82aed10f9f7966 1.jpg](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/9d70b70908579fd0f82aed10f9f7966%201.jpg)
		![04c5d85ec1ec438fa8ae88f9031dd4a.jpg](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/04c5d85ec1ec438fa8ae88f9031dd4a.jpg)
## lab7
### 步骤一
1. 4位4-1的verilog代码：
```verilog
module Mux4to1b4(
    input [1:0] S,
    input [3:0] D0,
    input [3:0] D1,
    input [3:0] D2,
    input [3:0] D3,
    output [3:0] Y
);
    // Instantiate 4 single-bit 4-to-1 multiplexers
    Mux4to1 mux0 (.S(S), .D0(D0[0]), .D1(D1[0]), .D2(D2[0]), .D3(D3[0]), .Y(Y[0]));
    Mux4to1 mux1 (.S(S), .D0(D0[1]), .D1(D1[1]), .D2(D2[1]), .D3(D3[1]), .Y(Y[1]));
    Mux4to1 mux2 (.S(S), .D0(D0[2]), .D1(D1[2]), .D2(D2[2]), .D3(D3[2]), .Y(Y[2]));
    Mux4to1 mux3 (.S(S), .D0(D0[3]), .D1(D1[3]), .D2(D2[3]), .D3(D3[3]), .Y(Y[3]));

endmodule

module Mux4to1(
    input [1:0] S,
    input D0,
    input D1,
    input D2,
    input D3,
    output reg Y
);
    always @ (S or D0 or D1 or D2 or D3) begin
        case (S)
            2'b00: Y = D0;
            2'b01: Y = D1;
            2'b10: Y = D2;
            2'b11: Y = D3;
        endcase
    end
endmodule
```
2. 仿真文件代码
```verilog
`timescale 1ns / 1ps

module Mux4to1b4_tb; 

    // 测试信号声明
    reg [1:0] S;
    reg [3:0] D0;
    reg [3:0] D1;
    reg [3:0] D2;
    reg [3:0] D3;
    wire [3:0] Y;

    // 实例化被测试的多路选择器
    Mux4to1b4 uut (
        .S(S),
        .D0(D0),
        .D1(D1),
        .D2(D2),
        .D3(D3),
        .Y(Y)
    );

    integer i, j, k, l, m; // 循环变量

    // 初始化过程
    initial begin
        // 多重循环遍历所有组合
        for (i = 0; i < 4; i = i + 1) begin
            for (j = 0; j < 16; j = j + 1) begin
                for (k = 0; k < 16; k = k + 1) begin
                    for (l = 0; l < 16; l = l + 1) begin
                        for (m = 0; m < 16; m = m + 1) begin
                            S = i;
                            D0 = j;
                            D1 = k;
                            D2 = l;
                            D3 = m;
                            #2; // 
                        end
                    end
                end
            end
        end
    end

endmodule

```
3. 仿真波形
	![Pasted image 20240421195956.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240421195956.png)![Pasted image 20240421200053.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240421200053.png)![Pasted image 20240421200032.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240421200032.png)![Pasted image 20240421200111.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240421200111.png)
	<mark style="background: #FFF3A3A6;">解释</mark>：S控制输出的端口，比如S=01时选择D1作为Y
### 步骤二
1. DisplaySync的设计文件
	1. 先将Mux4to1b4的src结尾的文件均拷贝到新电路程序
	2. 然后编写下列文件并set to top
```verilog
module DisplaySync(
    input [1:0] scan,
    input [15:0] hexs,
    input [3:0] points,
    input [3:0] LEs,
    output [3:0] HEX,
    output [3:0] AN,
    output point,
    output LE
);

    // 实例化四个Mux4to1b4模块
    // 对HEX的实例化
    Mux4to1b4 mux_hexs_inst(
        .S(scan),
        .D0(hexs[3:0]),
        .D1(hexs[7:4]),
        .D2(hexs[11:8]),
        .D3(hexs[15:12]),
        .Y(HEX)
    );

    // 对point的实例化
    Mux4to1b4 mux_points_inst(
        .S(scan),
        .D0({3'b000, points[0]}),
        .D1({3'b000, points[1]}),
        .D2({3'b000, points[2]}),
        .D3({3'b000, points[3]}),
        .Y({point})
    );

    // 对LE的实例化
    Mux4to1b4 mux_LE_inst(
        .S(scan),
        .D0({3'b000, LEs[0]}),
        .D1({3'b000, LEs[1]}),
        .D2({3'b000, LEs[2]}),
        .D3({3'b000, LEs[3]}),
        .Y({LE})
    );

    // 对AN的实例化
    Mux4to1b4 mux_AN_inst(
        .S(scan),
        .D0(4'b1110),
        .D1(4'b1101),
        .D2(4'b1011),
        .D3(4'b0111),
        .Y(AN)
    );

endmodule

```
2. 设计文件①
```verilog
module DisplaySync(
    input [1:0] scan,
    input [15:0] hexs,
    input [3:0] points,
    input [3:0] LEs,
    output [3:0] HEX,
    output [3:0] AN,
    output point,
    output LE
);

    // 实例化四个Mux4to1b4模块
    // 对HEX的实例化
    Mux4to1b4 mux_hexs_inst(
        .S(scan),
        .D0(hexs[3:0]),
        .D1(hexs[7:4]),
        .D2(hexs[11:8]),
        .D3(hexs[15:12]),
        .Y(HEX)
    );

    // 对point的实例化
    Mux4to1b4 mux_points_inst(
        .S(scan),
        .D0({3'b000, points[0]}),
        .D1({3'b000, points[1]}),
        .D2({3'b000, points[2]}),
        .D3({3'b000, points[3]}),
        .Y({point})
    );

    // 对LE的实例化
    Mux4to1b4 mux_LE_inst(
        .S(scan),
        .D0({3'b000, LEs[0]}),
        .D1({3'b000, LEs[1]}),
        .D2({3'b000, LEs[2]}),
        .D3({3'b000, LEs[3]}),
        .Y({LE})
    );

    // 对AN的实例化
    Mux4to1b4 mux_AN_inst(
        .S(scan),
        .D0(4'b1110),
        .D1(4'b1101),
        .D2(4'b1011),
        .D3(4'b0111),
        .Y(AN)
    );

endmodule

```
3. 设计文件②
```verilog
module DisplayNumber(
    input clk,
    input rst,
    input [15:0] hexs,
    input [3:0] points,
    input [3:0] LEs,
    output [3:0] AN,
    output [7:0] SEGMENT
);

    wire [1:0] scan;
    wire [3:0] HEX;
    wire point, LE;

    // 七段信号拆分为单独的线
    wire a, b, c, d, e, f, g, p;

    // 实例化时钟分频器模块，得到扫描信号
    wire [31:0] clkdiv_res;
    clkdiv clkdiv_instance(
        .clk(clk),
        .rst(rst),
        .div_res(clkdiv_res)
    );

    // 使用clkdiv的18和17位作为扫描信号
    assign scan = clkdiv_res[18:17];

    // 实例化DisplaySync模块
    DisplaySync display_sync_instance(
        .scan(scan),
        .hexs(hexs),
        .points(points),
        .LEs(LEs),
        .HEX(HEX),
        .AN(AN),
        .point(point),
        .LE(LE)
    );

    // 实例化MyMC14495模块
    MyMC14495 mymc14495_instance(
        .D0(HEX[0]),
        .D1(HEX[1]),
        .D2(HEX[2]),
        .D3(HEX[3]),
        .LE(LE),
        .point(point),
        .a(a),
        .b(b),
        .c(c),
        .d(d),
        .e(e),
        .f(f),
        .g(g),
        .p(p)
    );

    // 组合七段信号到一条线上
    assign SEGMENT = {a, b, c, d, e, f, g, p};

endmodule

```
### 解释
1. ❓<mark style="background: #BBFABBA6;">什么叫做扫描</mark>？
	1. 作用：用于控制多个显示设备（如数码管）的显示内容
	2. 每个数码管在一个非常短的时间内轮流被点亮，并显示它需要显示的数字或字符
	3. 显示的速度非常快，超过了人眼的视觉暂留效应阈值
	4. 原理：
		1. 使用一个4-1多路选择器来周期性地选择哪个数码管被激活（使能信号），以及应当显示什么数字（数据信号）。
		2. 由时钟分频器生成的连续信号控制），可以确保在任意给定的时间只有一个数码管被激活，并显示其对应的数字。
		3. 但由于扫描的速度非常快，所有数码管显示的内容会给观察者留下同时显示的印象。
2. ❓<mark style="background: #BBFABBA6;">如何利用时钟分频器与4-1多路选择器实现扫描功能？</mark>
	1. 对于时钟分频器
		1. 功能是每当输入时钟`clk`的正边沿到达时，它会更新一个32位的寄存器`div_res`。如果复位信号`rst`被激活（即当`rst`为高电平时），`div_res`会被重置为0。否则，每个`clk`的正边沿`div_res`的值就增加1。这种持续的计数功能可以用于生成各种时钟频率或作为基于时间的信号源。
		2. 可以从这个计数器中提取特定的位来生成所需的选择信号。这些选择信号用于控制多路选择器。
	2. 多路选择器方面
		1. 从四个输入中选择一个进行输出。这里的每个输入对应一个数码管的数字。
3. ❓<mark style="background: #BBFABBA6;">DisplaySync模块的工作原理</mark>![Pasted image 20240425103723.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240425103723.png)
	1. 流程：
		- 在一个完整的动态扫描周期内，`scan`信号会依次经历`00`, `01`, `10`, `11`四个状态。对于每一个`scan`状态：
		- 选择对应的`hexs`四位数字通过`mux_hexs`发送到`HEX`；
		- 选择对应的`points`位通过`mux_points`发送到`point`；
		- 选择对应的`LEs`位通过`mux_LE`发送到`LE`；
		- `mux_AN`会输出对应的控制信号到`AN`，只激活当前的显示器。
	>这个过程会非常快速地重复，以便所有的显示器似乎都同时显示数字。每个显示器只在其对应的`scan`信号状态下被激活，并显示其对应的数字和控制符号。
	2. Mux4-1b4将以scan传入的信号作为选择信号，hexs作为输入信号产生4位16进制数；points对应小数点；LE是符号；AN表示选择激活的数码管
4. 步骤：![Pasted image 20240425110801.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240425110801.png)

# 大程
## 基本要求
- 图片像素:640\*480
## 基本操作：
### LED的接口
```verilog
# set_property PACKAGE_PIN AF25 [get_ports ard_rst]
# set_property IOSTANDARD LVCMOS33 [get_ports ard_rst]
# set_property PACKAGE_PIN AF24 [get_ports {ard_led[0]}]
# set_property PACKAGE_PIN AE21 [get_ports {ard_led[1]}]
# set_property PACKAGE_PIN Y22 [get_ports {ard_led[2]}]
# set_property PACKAGE_PIN Y23 [get_ports {ard_led[3]}]
# set_property PACKAGE_PIN AA23 [get_ports {ard_led[4]}]
# set_property PACKAGE_PIN Y25 [get_ports {ard_led[5]}]
# set_property PACKAGE_PIN AB26 [get_ports {ard_led[6]}]
# set_property PACKAGE_PIN W23 [get_ports {ard_led[7]}]
# set_property IOSTANDARD LVCMOS33 [get_ports {ard_led[0]}]
# set_property IOSTANDARD LVCMOS33 [get_ports {ard_led[1]}]
# set_property IOSTANDARD LVCMOS33 [get_ports {ard_led[2]}]
# set_property IOSTANDARD LVCMOS33 [get_ports {ard_led[3]}]
# set_property IOSTANDARD LVCMOS33 [get_ports {ard_led[4]}]
# set_property IOSTANDARD LVCMOS33 [get_ports {ard_led[5]}]
# set_property IOSTANDARD LVCMOS33 [get_ports {ard_led[6]}]
# set_property IOSTANDARD LVCMOS33 [get_ports {ard_led[7]}]
```
### 背景图像的显示
- 得到二进制文件
```python
from PIL import Image
import numpy as np

# 读取图像
image = Image.open('image.jpg')

# 调整图像大小
image = image.resize((640, 480))

# 转换为RGB格式
image = image.convert('RGB')

# 获取像素数据
pixels = np.array(image)

```
```python
# 将像素数据转换为12位RGB格式
def rgb_to_12bit(rgb):
    r = (rgb[0] >> 4) & 0xF
    g = (rgb[1] >> 4) & 0xF
    b = (rgb[2] >> 4) & 0xF
    return (b << 8) | (g << 4) | r

# 创建12位颜色数据数组
pixel_data = np.zeros((480, 640), dtype=np.uint16)
for i in range(480):
    for j in range(640):
        pixel_data[i, j] = rgb_to_12bit(pixels[i, j])

# 保存为二进制文件，便于加载到FPGA
pixel_data.tofile('pixel_data.bin')

```
- 在vivado中指定对应的IP核，注意对应的长宽，位数等条件的设置；
- 在工程文件中实例化
```verilog
module vga_top (
    input wire clk,      // 系统时钟
    input wire rst,      // 复位信号
    output wire [3:0] r, // 红色信号
    output wire [3:0] g, // 绿色信号
    output wire [3:0] b, // 蓝色信号
    output wire hs,      // 水平同步信号
    output wire vs       // 垂直同步信号
);
    // VGA时钟生成
    wire vga_clk;
    clk_wiz_0 clk_gen (
        .clk_in1(clk),
        .clk_out1(vga_clk),
        .reset(rst),
        .locked()
    );

    // VGA控制器信号
    wire [11:0] pixel_data;
    wire [8:0] row_addr;
    wire [9:0] col_addr;
    wire rdn;

    // VGA控制器实例
    vgac vga_controller (
        .vga_clk(vga_clk),
        .clrn(~rst),
        .d_in(pixel_data),
        .row_addr(row_addr),
        .col_addr(col_addr),
        .rdn(rdn),
        .r(r),
        .g(g),
        .b(b),
        .hs(hs),
        .vs(vs)
    );

    // BRAM实例
    blk_mem_gen_0 bram (
        .clka(vga_clk),
        .ena(1),
        .wea(0),
        .addra({row_addr, col_addr}),
        .dina(12'b0),
        .douta(pixel_data)
    );

endmodule

```
