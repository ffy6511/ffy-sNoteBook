---
{"dg-publish":true,"permalink":"/obsidian///fds//4/","created":"2024-04-08T12:06:58.539+08:00","updated":"2024-09-08T15:25:05.388+08:00"}
---

# 故事的开始：二叉堆
- 具有的特性
	- 结构性（完全二叉树）
		- 高为h则有$2^h$~$2^{h+1}$-1个节点
		- ![Pasted image 20240408132727.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240408132727.png)
	- 堆序性(教材认为从1开始--2i+1,2i+2)
		- 认为根节点的索引**从0开始**时；
		- 左子树$2i$,右子树$2i+1$
		- 从子树$n$找到父节点的索引,只需计算$n$/2，自动取整
- 数据结构的组成
	- 一个数组
	- 一个代表最大内存的整数
	- 一个表示当前堆的大小的整数
- 定理
	- <mark style="background: #ADCCFFA6;">完美二叉树</mark>
		- 高为h-->具有$2^{h+1}$-1个节点；
		- 节点的高度和为$2^{h+1}$-1-(h+1);
## 堆的结构体定义
```
typedef struct heap{
	int* val;    //指向元素的指针（不一定为整型）
	int size;    //当前的大小
	int capacity；   //最大的容量
}Heap;
```
# 1.各种堆
## 1.1 最小堆
- 特殊的**完全二叉树**
- 每个节点的值都<mark style="background: #FFF3A3A6;">小于等于其子节点的值</mark>
- 根节点的值是堆中的最小值
- 通常用**优先队列**实现
### 相关函数
#### 结构体
```c
typedef struct MinHeap{
	int* val;
	int size;
	int capacity;
}MinHeap;
```
#### ①初始化
```c
void initMinHeap(MinHeap* heap ,int capacity)
{
	heap->val = (int*)malloc(sizeof(int)*capacity);
	heap->size = 0;
	heap->capacity = capacity;
}
```
#### ②释放堆
```c
void freeMinHeap(MinHeap* heap)
{
	free(heap->val);
	heap->val = NULL;
	heap->size = 0;
	heap->capacity = 0;
}
```
#### ③插入（逐渐<mark style="background: #ADCCFFA6;">上浮</mark>）
```c
void insertMinHeap(int x,MinHeap* heap)
{
	if (heap->size == heap->capacity){
		printf("The heap is full!\n");
		return;
		}
	int i ;
	for(i = ++(heap->size); i > 1 && heap->val[ i/2 ] > x; i /=2)
		heap->val[i] = heap->val[i/2];
	heap->val[i] = x;
	}
```
#### ④删除最小元
**思路：**
>将根节点（的值）删除后，用最后的节点值代替当前的根节点；
>我们需要将lastVal不断下潜，让最后一个元素找到合适的位置--<mark style="background: #ADCCFFA6;">下滤</mark>

**代码：**(此处认为根节点的索引从1开始)
```c
int deleteMin(MinHeap* heap)
{
	if(heap->size == 0){
		printf("The heap is empty!\n");
		return NULL;
	}
	int i,child;
	int minVal,lastVal;
	minVal = heap->val[1];  //为返回删除的最小值做准备
	lastVal =heap->val[heap->size];
	heap->size --;
	
	for( i =1;i*2 <=heap->size; i = child){
		child = i*2;
		// 检查是否有右子节点，并且右子节点的值是否小于左子节点
		if(child != heap->size && heap->val[child+1] < heap->val[child])
			child+=1;
			
		// 如果最后一个元素的值大于子节点中的较小者，则进行下沉
		if(lastVal > heap->val[child])
			heap->val[i] = heap->val[child];
		else
			break;
	}
	heap->val[i] = lastVal;
	return minval;
}
```

#### ⑤线性时间构造MinHeap
>a.对于简单的构造：每次都对数组取元素置于已构建的MinHeap的末尾，然后不断上浮，每次所用的时间为$log {n}$，共进行$n$次，故时间复杂度为O（$nlog{n}$）。
>b.下面为如何利用O($n$)的时间复杂度实现构造的方法
- 含义：对一个未排列的数组进行操作
- <mark style="background: #ADCCFFA6;">heapify</mark>(根节点从0开始)
```c
void swap(int* x,int* y){
	int tmp = *x;
	*x = *y;
	*y = tmp;
}
void heapify(MinHeap* heap,int i)
{
	int Min = i;
	int left = 2*i;
	int right = 2*i+1;
	//寻找较小的元素:如果子节点更小， 将其与根节点调换
	if(left <= heap->size && heap->val[left] < heap->val[Min])
		Min = left;
	if(right <= heap->size && heap->val[right] < heap->val[Min])
		Min = right;
	//如果子节点中有比根节点还小的值，对换
	if(i != Min){
		swap(&heap->val[Min],&heap->val[i]);
		// 递归地调整受影响的子树
		heapify(heap,Min);
	}
	//当满足最小堆的性质时，跳出递归
}
```
- <mark style="background: #ADCCFFA6;">buildHeap</mark>
```c
void buildHeap(MinHeap* heap){
	// 堆中最后一个非叶子节点的索引是(size/2) - 1
	for(int i=(heap->size/2); i>0; i--){
		heapify(heap,i);
	}
}
```
<mark style="background: #BBFABBA6;">为什么从最后一个非叶子节点开始调整？</mark>
	所有的叶子节点都没有子节点，因此自然满足了最小堆的性质
<mark style="background: #BBFABBA6;">为什么传入一个最小堆类型的指针？</mark>
	这个结构体指针指向的对象包含了数组（可以是未排列、待操作的），最小堆的容量以及当前的大小
### 其他操作
#### ①DecreaseKey
- 含义
	减小某个元素的值，并根据新的值重新调整堆
- 操作
	减小键值-->上浮调整
- 代码(认为根节点的索引从0开始)
```c
void DecreaseKey(MinHeap* heap,int index,int newValue)
{
	if(index<0 || index >= heap->size || newValue >= heap->val[index])
	{
		printf("Invalid operation!\n");
		return ;
	}
	heap->val[index] = newValue;
	while(index > 0 && heap->val[(index-1)/2] > heap->val[index]){
		int tmp = heap->val[index];
		heap->val[index] = heap->val[(index-1)/2];
		heap->val[(index-1)/2] = tmp;

		index = (index-1)/2;
	}
}
```
>根节点的索引从0/1开始的区别，映射到代码上的体现——
>寻找父节点时：0开始对应 val[(index-1)/2]；1开始对应 val[index/2];
>搜索子节点时，0开始对应2i+1/2i+2；1开始对应2i/2i+1
#### ②IncreaseKey
- 代码(根节点的索引从0开始)
```c
void Increasekey(MinHeap* heap,int index,int newValue)
{
	if(index>heap->size || index<0 ||heap->val[index] > newValue)
	{
		printf("Invalid operation!\n");
		return ;
	}
	heap->val[index] = newValue;
	int child;
	for(int i = index; i*2+1 < heap->size;  i = child ){
		child = i*2+1;   //左子节点索引的计算（根节点的索引为0）
		// 如果有右子节点，并且右子节点的值小于左子节点的值
		if(child +1< heap->size && heap->val[child+1] < heap->val[child])
			child+=1;//   使用右子节点
		// 如果新值大于较小的子节点，则进行下沉
		if(newValue > heap->val[child])
			heap->val[i] = heap->val[child];
		else
			break;
	}
	heap->val[ i ] = newValue ;
}
```
### 模拟实现
#### ①最小堆的生成
>所需的函数已在上面给出
```c
int main() {
    // 一个未排序的数组
    int arr[] = {3, 2, 1, 15, 5, 4, 45};
    int size = sizeof(arr)/sizeof(arr[0]);
    
    // 创建MinHeap并分配内存
    MinHeap heap;
    heap.size = size;
    heap.val = (int*)malloc(size * sizeof(int));
    for (int i = 0; i < size; i++) {
        heap.val[i] = arr[i];
    }
    
    // 构建最小堆
    buildHeap(&heap);
    
    // 打印构建后的最小堆
    printf("Min Heap: ");
    for (int i = 0; i < heap.size; i++) {
        printf("%d ", heap.val[i]);
    }
    printf("\n");
    
    // 清理
    free(heap.val);
    
    return 0;
}

```
## 1.2 d-堆
- 性质
	- 二叉堆的推广，度为$d$
	- 同样具有结构性与堆序性
		- 令根节点的**索引为0**时
		- 父->子
			- 若父节点的索引为$i$则，左子树为$d$ x $i$+$k$
			- $k$为1~$d$
		- 子->父
			- 子节点的索引为$i$时
			- 父节点的索引为($i-1$)/$d$---计算机运算自动向下取整
	- 分为最小d-堆和最大d-堆
- 优势
	- 减小的堆的高度
- HW ![Pasted image 20240408165403.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240408165403.png)