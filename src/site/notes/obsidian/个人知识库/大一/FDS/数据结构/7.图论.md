---
{"dg-publish":true,"permalink":"/obsidian///fds//7/","created":"2024-04-17T09:27:05.683+08:00","updated":"2024-09-08T15:25:05.394+08:00"}
---

# 引言
1. 对对象之间的成对关系建模的数学结构
2. 组成
	1. 顶点 <mark style="background: #ADCCFFA6;">V</mark>ertex
	2. 边    <mark style="background: #ADCCFFA6;">E</mark>dge
3. 一般来说，点集不能为空，边集可以为空
4. 分类
	1. 有向图 & 无向图
	2. 有权图 & 无权图
5. 图的子集
	点集与边集都为~的子集
	如果边在其中，那么边的两个顶点也在点集中
6. 路径的长度=边数
7. <mark style="background: #ADCCFFA6;">Simple path</mark> : 不存在圈的图
8. 无向图（默认为~）
	1. <mark style="background: #ADCCFFA6;">Component</mark> of an Undirected G
		1. 定义：<mark style="background: #BBFABBA6;">最大</mark>的连通的子图
			1. 再加入任意的点、边后不能继续连通
		2. 注意：<mark style="background: #FFF3A3A6;">最大是相对的</mark>，即一张图可以有不同区域、不同大小的~
		3. ❓<mark style="background: #FFB86CA6;">一个点本身算不算connected component?</mark>
			✅算
	2. 无向图只有连通与否，而无强弱之分
9. 缩写
	1. DAG: 有向无环图
10. <mark style="background: #ADCCFFA6;">有向图</mark>
	1. **强连通** *strongly connected*
		1. 定义：任意顶点之间的<mark style="background: #FFF3A3A6;">往返</mark>均有路径
		2. Strongly connected component 强连通分量
			1. 一个点本身也是一个~
		3. ❓<mark style="background: #FFB86CA6;">一个点仅有入度 or出度是否算分量？</mark>
			✅是的，依照定义
	2. **弱连通** *weakly connected*
		1. 定义：不是强连通，但是排除方向后是连通的，就称为~
11. degree 度
	1. 图的度指的是<mark style="background: #FFF3A3A6;">每个点</mark>的度
	2. 分为 in-degree(v)与out-degree(v)
# 图的表达形式
## 邻接矩阵
>1. 适用于稠密图
>2. 如果有权重，矩阵的值可以用权重代替
### 结构体
```c
typedef struct{
	int num_v;
	int arr[maxSize][maxSize];
}Graph;
```
### 基本操作函数
```c
// 初始化图，包括顶点数量和邻接矩阵
void initGraph(Graph *g, int num_v) {
    g->num_v= num_v;
    for (int i = 0; i < num_v; i++) {
        for (int j = 0; j < num_v; j++) {
            g->arr[i][j] = 0;  // 初始化所有连接为0，表示无边
        }
    }
}
void addEdge(Graph *g, int start, int end) {
    g->arr[start][end] = 1;  // 无向图添加两条边
    g->arr[end][start] = 1;  // 如果是有向图，则只添加一条
}


```
## 邻接表
>1. 适用于稀疏图
>2. 对于$n$个顶点，开设一个以指针为元素的一维数组，指向每个顶点
>3. 每个链表的节点都表示当前的点所指向的节点，虽然链表的节点指向是有先后的，但是对于地位相等的点来说，我们应当忽略这些先后。或者说，点在链表中出现的位置并没有关系。只是按照边的添加的逻辑，新添加的节点将成为链表的头节点，因此在前而已。
>4. 如果有权重，需要在节点的定义中加入新的权重成员
### 结构体
```c
// 邻接表中的节点结构
typedef struct node {
    int vertex;  // 顶点
    struct node* next;  // 指向下一个节点的指针
} Node;

// 邻接表图结构
typedef struct {
    int n;  // 顶点数
    Node* adjList[MAX_VERTICES];  // 邻接表数组
} Graph;
```
### 图的读取与加边操作
```c
#include <stdio.h>
#include <stdlib.h>

#define maxSize 100
typedef struct graphNode {
    int position;       // 顶点所在adjList中的索引
    struct graphNode* next;
} graphNode;

// 图的定义
typedef struct {
    int numVertex;       // 顶点个数
    graphNode* adjList[maxSize]; // 存放指定顶点指向的链表
    int inDegree[maxSize]; // 存放每个顶点的入度的数组
} Graph;

// 函数声明
void initializeGraph(Graph* g, int numVertex);
void addEdge(Graph* g, int start, int end);
void printGraph(Graph* g);

int main() {
    Graph g;
    int numVertex, numEdges;
    int start, end;

    printf("Enter the number of vertices: ");
    scanf("%d", &numVertex);     //读入顶点数
    initializeGraph(&g, numVertex);//利用顶点数初始化图

    printf("Enter the number of edges: ");
    scanf("%d", &numEdges);
    for (int i = 0; i < numEdges; i++) {
        printf("Enter edge (start end): ");
        scanf("%d %d", &start, &end);//读入边的数据
        addEdge(&g, start, end);
    }

    printGraph(&g);
    return 0;
}

void initializeGraph(Graph* g, int numVertex) {
    g->numVertex = numVertex;
    for (int i = 0; i < numVertex; i++) {
        g->adjList[i] = NULL;//注意一般索引为0的位置对应顶点0
        g->inDegree[i] = 0;
    }
}

void addEdge(Graph* g, int start, int end) {
    graphNode* newNode = malloc(sizeof(graphNode));
    newNode->position = end;//指向顶点的索引就是顶点的position
    newNode->next = g->adjList[start];//插入节点到链表的开头
    g->adjList[start] = newNode;//越晚插入，位置越靠前，但是地位相同

    // 无向图，所以需要添加相反方向的边
    newNode = malloc(sizeof(graphNode));
    newNode->position = start;
    newNode->next = g->adjList[end];
    g->adjList[end] = newNode;

    // 更新入度
    g->inDegree[start]++;
    g->inDegree[end]++;
}

void printGraph(Graph* g) {
    for (int i = 0; i < g->numVertex; i++) {
        graphNode* tmp = g->adjList[i];
        printf("Adjacency list of vertex %d:\n head", i);
        //遍历一个链表所有的节点，也就是顶点指出的顶点
        while(tmp != NULL) {
            printf(" -> %d", tmp->position);
            tmp = tmp->next;
        }
        printf("\n");
    }
}

```
### 检验边是否存在
```c
//检查前者顶点是否有指向后者顶点的边
int hasEdge(Graph* G,int former,int latter){
	graphNode* tmp = G->adjList[former];
	while(tmp != NULL){
		if(tmp->position == latter)
			return 1;
		tmp = tmp->next;
	}
	return 0;
}
```
### 打印邻接表的结果
```c
void printGraph(Graph *G) {
    for (int v = 0; v < G->n; v++) {
        Node *temp = G->adjList[v];
        printf("\n Adjacency list of vertex %d\n head ", v);
        while (temp) {
            printf("-> %d", temp->vertex);
            temp = temp->next;
        }
        printf("\n");
    }
}
```
### 时间复杂度
入度
1. 加入反向表
2. 运用十字链表
出度

### <mark style="background: #FFB86CA6;">有向加权的邻接表</mark>

## 相关算法--拓扑排序
### <mark style="background: #BBFABBA6;">拓扑排序</mark>
1. **作用**：将有向图的所有顶点排列成线性序列
2. **前提**：图必须是<mark style="background: #FFF3A3A6;">有向无环图</mark> $DAG$
3. **特点**：对于图中的任意两个顶点$u$和$v$，如果存在一条从$u$到$v$的有向边，那么在排序结果中$u$必须出现在$v$之前。
4. 分类
	1. AOV:用顶点表示活动，边表示活动的先后
	2. AOE:用顶点表示活动的开始与结束，用边表示活动本身
5. 相关概念
	1. predecessor:   前序
	2. successor:       后序
	3. Patial order:同时具有**可传递性**transitive与**非自反性**irreflextive
	4. 拓扑序 topolpgical order
6. 时间复杂度 $O[(v)+(E)]$ 
7. 
### 整体思路：
1. 队列等结构体的定义
2. 遍历图的节点，将入度为0的节点（索引）入队存储
3. 接着从非空的队列中取出一个节点
		1. 先打印该顶点的索引与拓扑序号
		2. 然后遍历该顶点指向的顶点（通过链表），并令它们入度--
		3. 每次遍历时，让新的顶点入队
4. 队列为空时跳出循环
5. 如果拓扑序号不等于顶点数，说明存在环（环内顶点一直未入队）
### 代码实现
#### 结构体定义
```c
//顶点的定义
typedef struct graphNode {
	int position;		//顶点所在adjList中的索引
	graphNode* next;
}graphNode;
//图的定义
typedef struct Graph {
	int numVertex;		//顶点个数
	graphNode* ajdList[maxSize];//存放指定顶点指向的链表
	int inDegree[maxSize];//存放每个顶点的入度的数组
};
//队列节点的定义
typedef struct QueueNode {
	int val;	
	QueueNode* next;
}QueueNode;

//队列结构体的定义
typedef struct Queue {
	QueueNode* front;//指向队列首元素的指针
	QueueNode* rear;//指向队列末元素的指针
}Queue;
```
#### 队列相关函数的定义
```c
//未知总数时利用链表创建新的队列
Queue* createQueue() {
	Queue* q = (Queue*)malloc(sizeof(Queue));
	if (q == NULL) {
		printf("Out of space!\n");
		return NULL;
	}
	q->front = NULL;
	q->rear = NULL;
	return q;
}

//判断队列是否为空
int IsEmpty(Queue* q) {
	return q->front == NULL;
}

//入队操作
void EnQueue(int x, Queue* q) {
	QueueNode* newNode = (QueueNode*)malloc(sizeof(QueueNode));
	if (newNode == NULL) {
		printf("Our of space!\n");
		return;
	}	
	newNode -> val = x;
	if (IsEmpty(q)){
		q->front = newNode;
		}
	else {
		newNode->next = q->rear;
		q->rear = newNode;
	}
}

//出队操作
int DeQueue(Queue* q) {
	if (IsEmpty(q)) {
		printf("Queue is empty!\n");
		return -1;
	}
	QueueNode* tmp = q->front;
	int val = tmp->val;
	q->front = q-> front->next;
	free(tmp);
	return val;
}

//释放队列内存
void FreeQueue(Queue* q) {
	while (!IsEmpty(q))
		DeQueue(q);
	free(q);
}
```
- ❓<mark style="background: #BBFABBA6;">creatQueue返回的是指向队列的指针，而非队列本身</mark>
	- ✅
	1. **性能考虑**：
		- 结构体可能较大，直接返回整个结构体可能涉及到复制整个结构体的成本。而返回指针仅涉及返回一个内存地址，这通常是一个固定大小的小值
	2. **错误处理**：
		- 使用指针可以在内存分配失败时通过返回`NULL`来轻松地检测和处理错误情况。
#### 拓扑排序
```c
//拓扑排序
void TopSort(Graph G) {
	Queue* Q = createQueue();//新建一个队列
	int counter = 0;     //用于对遍历时入度可为0的节点计数
	//第一次遍历，找到初始入度为0的顶点并入队
	for (int i = 0; i < G.numVertex; i++) {
		if (G.inDegree[i] == 0)
			EnQueue(i, Q);
	}
	//第二次遍历
	//每次从队列中出队一个顶点（打印）
	//将这个顶点指向顶点的入度--（该顶点被打印过）
	while (!IsEmpty(Q)) {
		int current = DeQueue(Q);
		counter++;
		printf("Vertex:%d -> %d",current,counter);//输出顶点与对应的拓扑序号
		graphNode* tmp = G.adjList[current];  //当前顶点指向的顶点地址
		while (tmp != NULL) {
			G.inDegree[tmp->position]--;  //减少入度
			//如果入度为0，继续入队
			if (G.inDegree[tmp->position] == 0)
				EnQueue(tmp->position,Q );
			tmp = tmp->next;     //遍历初始顶点所指向的所有顶点
		}
	}
	if (counter != G.numVertex)
		printf("The graph has at least a cycle\n");
	FreeQueue(Q);
}
```
- ❓为什么graphNode的val就是顶点的序号？
	- ✅
		1. graphNode实际上是从start到end的一条边
		2. 节点的position是实际顶点的位置（在adjList中的索引)
		3. addEdge函数新建的节点实际上是新建边
		4. 因此,G->adjList[i] 表示顶点i指出顶点构成的链表
		5. graphNode的指针ptr是adjList的成员，~~且ptr->val是实际上的顶点的值~~,上述内容并没有存储顶点的值,position就是索引

# 最短路径算法
- 特点：
	1. 边被赋值，具有权重
- 分类
	1. Single source 单源最短路径
## 单源最短路径
- 含义：从单源出发，计算与其他所有点的最短路径
- 存在负数的权值时
	- 两点间的最短路径并不确定
	- 若要使得权值和最小，会进入<mark style="background: #BBFABBA6;">负值圈</mark>negative-cost cycle的循环
	- 此时，任何的算法都将失效（无法在有限步内中止）
- 分类
	- 无权最短路径（可以视作权值均为1）
		- 广度优先搜索 breadth-first search
	- 赋权最短路径（不存在负权值）
		- Dijkstra 算法
## BFS
>与树的层序遍历相似，但是可能存在环；需要加入标记，防止陷入循环
- 实现的概述
	- 利用<mark style="background: #FFF3A3A6;">队列</mark>实现类似于树的层序遍历（因为离`根`较近的元素先被遍历到）
	- 在图的结构体定义中加入<mark style="background: #FFF3A3A6;">记录节点是否被访问过</mark>的数组visited,防止陷入循环
- ❓同时实现对路径的输出
	- 用单链表存储每一对点之间的最短路径
### 简单实现
>使用了数组记录是否visited, 无法输出路径
#### 结构体实现
```c
// 队列节点
typedef struct QueueNode {
    int vertex;
    struct QueueNode* next;
} QueueNode;

// 队列结构
typedef struct {
    QueueNode *front, *rear;
} Queue;

// 图的节点
typedef struct GraphNode {
    int vertex;
    struct GraphNode* next;
} GraphNode;

// 图结构
typedef struct {
    int numVertices;
    GraphNode** adjLists;
    int* visited;
} Graph;

// 创建队列
Queue* createQueue() {
    Queue* q = (Queue*)malloc(sizeof(Queue));
    q->front = q->rear = NULL;
    return q;
}
```
#### 队列相关的函数实现
```c
void enqueue(Queue* q, int vertex) {
    QueueNode* newNode = (QueueNode*)malloc(sizeof(QueueNode));
    newNode->vertex = vertex;
    newNode->next = NULL;
    if (q->rear == NULL) {
        q->front = q->rear = newNode;
    } else {
        q->rear->next = newNode;
        q->rear = newNode;
    }
}

// 出队
int dequeue(Queue* q) {
    if (q->front == NULL) return -1;
    QueueNode* temp = q->front;
    int vertex = temp->vertex;
    q->front = q->front->next;
    if (q->front == NULL) q->rear = NULL;
    free(temp);
    return vertex;
}

// 队列是否为空
int isEmpty(Queue* q) {
    return q->front == NULL;
}
```
#### 图的相关函数实现
```c
// 创建图
Graph* createGraph(int vertices) {
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    graph->numVertices = vertices;
    graph->adjLists = (GraphNode**)malloc(vertices * sizeof(GraphNode*));
    graph->visited = (int*)malloc(vertices * sizeof(int));

    for (int i = 0; i < vertices; i++) {
        graph->adjLists[i] = NULL;
        graph->visited[i] = 0;
    }
    return graph;
}

// 添加边
void addEdge(Graph* graph, int src, int dest) {
    // 添加从 src 到 dest 的边
    GraphNode* newNode = (GraphNode*)malloc(sizeof(GraphNode));
    newNode->vertex = dest;
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;
}
```
#### BFS函数
```c
// BFS 函数
void BFS(Graph* graph, int startVertex) {
    Queue* queue = createQueue();
    graph->visited[startVertex] = 1;
    enqueue(queue, startVertex);

    while (!isEmpty(queue)) {
        int currentVertex = dequeue(queue);
        printf("Visited %d\n", currentVertex);

        GraphNode* temp = graph->adjLists[currentVertex];

        while (temp) {
            int adjVertex = temp->vertex;

            if (graph->visited[adjVertex] == 0) {
                graph->visited[adjVertex] = 1;
                enqueue(queue, adjVertex);
            }
            temp = temp->next;
        }
    }
}
```
### 优化实现
- 修改之处
	1. 引入表项结构体`TableEntry`：用于存储节点的是否已知、距离与前驱顶点
	2. 修改了BFS函数，利用`TableEntry`来更新节点的状态
#### TableEntry
```c
typedef struct {
    int Known;  // 标记顶点是否已经被访问过
    int Dist;   // 从源顶点到该顶点的距离
    Vertex Path; // 记录到达该顶点的前一个顶点（用于重建路径）
} TableEntry;
```
#### BFS
```c
void Unweighted(Graph* g, TableEntry* T, Vertex S) {
    Queue* Q = createQueue();  // 创建一个队列
    enqueue(Q, S);             // 将源顶点入队
    T[S].Dist = 0;             // 源顶点到自身的距离是0

    while (!isEmpty(Q)) {      // 当队列不为空时，循环执行
        Vertex V = dequeue(Q); // 出队一个顶点
        T[V].Known = 1;        // 标记该顶点为已访问

        for (GraphNode* temp = g->adjLists[V]; temp != NULL; temp = temp->next) {
            Vertex W = temp->vertex;
            if (T[W].Dist == INFINITY) {  // 如果这个顶点未被访问过
                T[W].Dist = T[V].Dist + 1;  // 更新距离
                T[W].Path = V;             // 更新路径
                enqueue(Q, W);             // 将该顶点入队
            }
        }
    }
    free(Q);  // 释放队列内存
}
```
#### 输出最短路径
```c
void printPath(TableEntry* T, Vertex v) {
    if (T[v].Dist == INFINITY) {
        printf("No path exists to vertex %d\n", v);
        return;
    }
    if (T[v].Path == -1) {  // 如果是源顶点，它的Path值应被初始化为-1
        printf("%d", v);
    } else {
        printPath(T, T[v].Path);  // 递归调用以打印前一个顶点的路径
        printf(" -> %d", v);       // 打印当前顶点
    }
}
```

## Dijkstra 算法
- 特点
	1. 适用于只含有非负权重的图
	2. 是一种贪心算法
	3. 每一步选取<mark style="background: #FFF3A3A6;">尚未处理的具有最小距离的顶点</mark>，更新信息
		1. 此后该点被标记为`已处理`，并且表示已经找到了到该点的最短路径
### 模拟实现：
- 图示![Pasted image 20240426162510.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240426162510.png)
- 流程：![Pasted image 20240426162538.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240426162538.png)
- 总结：被标记/确定了最短路径的顺序为：2-4-3-6-5-7
### 代码
利用邻接矩阵来存储图
```c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// 定义图的顶点结构
typedef struct {
    int dist;     // 从源到该顶点的最小距离
    int known;    // 该顶点的最短路径是否已知
    int path;     // 最短路径中该顶点的前驱顶点
} Vertex;

// 定义图的结构
typedef struct {
    int numVertices;      // 顶点数
    int** edges;          // 邻接矩阵，存储边的权重
} Graph;

// 创建图
Graph* createGraph(int numVertices) {
    Graph* g = malloc(sizeof(Graph));
    g->numVertices = numVertices;
    g->edges = malloc(numVertices * sizeof(int*));
    for (int i = 0; i < numVertices; i++) {
        g->edges[i] = malloc(numVertices * sizeof(int));
        for (int j = 0; j < numVertices; j++) {
            g->edges[i][j] = INT_MAX; // 初始化为无穷大，表示无边连接
        }
    }
    return g;
}

// 添加边
void addEdge(Graph* g, int src, int dest, int weight) {
    g->edges[src][dest] = weight; // 设置源到目标的边的权重
}

// 找到未知的最小距离顶点
int findSmallestUnknown(Vertex* vertices, int size) {
    int minDistance = INT_MAX;
    int minVertex = -1;
    for (int i = 0; i < size; i++) {
        if (!vertices[i].known && vertices[i].dist < minDistance) {
            minDistance = vertices[i].dist;
            minVertex = i; // 寻找未处理且距离最小的顶点
        }
    }
    return minVertex;
}

// Dijkstra 算法实现
void dijkstra(Graph* g, Vertex* vertices, int startVertex) {
    vertices[startVertex].dist = 0; // 设置起点的距离为0

    while (1) {
        int v = findSmallestUnknown(vertices, g->numVertices);
        if (v == -1) break; // 如果没有未知的最小距离顶点，则结束循环

        vertices[v].known = 1; // 将该顶点标记为已知，表示其最短路径已经确定
        for (int w = 0; w < g->numVertices; w++) {
            if (g->edges[v][w] != INT_MAX && !vertices[w].known) {
		            // 如果找到更短的路径，则更新顶点w的距离和前驱
                if (vertices[v].dist + g->edges[v][w] < vertices[w].dist) {
                    vertices[w].dist = vertices[v].dist + g->edges[v][w];
                    vertices[w].path = v; // 更新邻接顶点的最短路径和前驱
                }
            }
        }
    }
}
```
## AOE 
- activity on edge 边长表示活动，不同于拓扑排序表示的顶点存储信息![Pasted image 20240508104112.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240508104112.png)
## 多源最短路径
- 相关算法： Floyd算法
# 4.网络流 Network Flow Problems
- **对象**
	- 有向加权图，认为权重表示流量
	- 存在`source`和`sink`
	- 每个中间顶点不能存储流量，即每个中间顶点的入度等于出度
	- 每条边的权值称为`Capacity`,表示最多可以通过此边的流量
- **目标**
	- 找出从`source`到`sink`的最大流量
##  简单算法
- 原理图：![Pasted image 20240508105817.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240508105817.png)
- 解释：
- 潜在问题：
	- 随机选取的路径可能导致路径的单一化
## 改进
- 解释：
1. 在流量图中构建一条路径、更新余量图的同时--
2. 在余量图中增加反向的边 
3. 在之后查找s->t的路径时，采取正常的无权图（计入方向的边）查找方式
- 原理图：![Pasted image 20240508110243.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240508110243.png)
## 复杂度分析
## min-cost flow 问题
- 描述：保证最大流量的情况下，找到最小成本的路径
# 5.最小生成树 
>Minimun Spanning Tree
## 定义：
1. tree : 无环图，顶点数=边数-1
2. minimun : 总的cost最小
3. spanning : 包含每一个顶点
4. 当且仅当 `G`是connected时，~存在
- 从一个graph可以得到它的~
## 贪心算法实现
- 规则：
	1. 仅仅采用graph中存在的边
	2. 精确采用`V-1`条边
	3. 不能选用会因此产生`cycle`的边
算法介绍：
### Prim's 算法
> grow a tree （与Dijkstra算法相近）
- 思路：
	1. 从某个确定的顶点u出发，寻找最近的顶点v，
	2. 每次选取时额外观察：
		1. 最短的这条路径是否形成环
		2. 此时收录的顶点数是否已满
### Kruskal's 算法
>maintain a forest
- 思路：
	1. 将顶点初始化看做森林
	2. 每次检查边非空，并选取<mark style="background: #FFF3A3A6;">最短的边</mark>
		1. 可以用<mark style="background: #ADCCFFA6;">最小堆</mark>实现 —  $log\ (E)$的时间复杂度
	3. 检查该边<mark style="background: #FFF3A3A6;">不构成环</mark>，否则将该边丢弃
		1. 当该边的两个顶点本身就在一棵树中时，加入的边会形成环
		2. **转化为判断**：顶点<mark style="background: #FFF3A3A6;">是否已经在同一棵树中</mark>
			1. 可以用<mark style="background: #ADCCFFA6;">并查集</mark>实现  为线性的时间复杂度
			2. Find($V_1$) 与 Find($V_2$)，若结果不同（不在一棵树）则Union
- 分析：
	- 用最小堆实现使得算法本身的时间复杂度为O($E$$logE$)
	- 但是实际实现时，可以直接根据边的权值`sort`（时间复杂度不确定）
	- 当图为稀疏图（V与E近似相等)时，优先考虑这种算法
- 步骤：
	1. 将所有的边按照非降序排列
	2. 选择当前权值最小且不构成环的边
		1. 用并查集检验是否在同一颗树当中
	3. 将每次选择的边存放在一个<mark style="background: #ADCCFFA6;">边集数组</mark>当中/直接将sum++对应值
- 伪代码：
```c
void Kruscal(Graph G) {
    int EdgesAccepted;   //收录符合条件的边
	DisjSet S;  //包含顶点信息的并查集
    PriorityQueue H;  //如果要用最小堆取出边，可以采用优先队列构建
    Vertex U, V;//每次比较的两个顶点
    SetType Uset, Vset;//并查集中Find的搜索结果
    Edge E;//边
    Initialize(S);   //初始化并查集（元素均赋值为-1）
    ReadGraphIntoHeapArray(G, H);   //给出图的信息，依据边的权值初始化最小堆的数组
    BuildHeap(H);  //将初始化的数组线性构建最小堆

    EdgesAccepted = 0;   //初始化已收录的边为0
    //合理的最小生成树的边数正好为顶点数-1
    while (EdgesAccepted < NumVertex - 1) {
        E = DeleteMin(H);//取出最小权值的边
        //检查边的两个顶点是否构成环（是否在同一个集合中）
        Uset = Find(U, S);
        Vset = Find(V, S);
        //比较顶点所在的集合是否相同
        if (Uset != Vset) {
            //Accept the edge
        }EdgesAccepted++;
        SetUnion(S, Uset, Vset);
    }
```
#### 代码：
①结构体
```c
//边结构体
typedef struct edge{
```
## 算法选择总结
- 稀疏图-- Prim's
	- 采用邻接矩阵存储边的关系
- 稠密图--Kruskal's
	- 采用邻接表存储边的关系
	- 用<mark style="background: #FFB86CA6;">结构体edge</mark>来存储信息！
## 判断MST的存在性和唯一性
### <mark style="background: #BBFABBA6;">存在性</mark>
- 我们知道，<mark style="background: #FFF3A3A6;">有向图存在MST的充要条件是连通</mark>
- 因此，使用并查集的操作方式，检验对所有顶点操作之后的集合个数即可
### <mark style="background: #BBFABBA6;">唯一性</mark>
对于非降序排列的边，如果存在相同权值则标记`flag`为1
利用贪心算法得到`sum`
若`flag`为0则MST一定唯一
若`flag`为1，则<mark style="background: #FFF3A3A6;">依次减去这些边</mark>，直到仍存在MST且sum相同，则MST不唯一
# 6. DFS的应用
## 📝什么是DFS？
>树的前序遍历
- 访问顺序：尽可能深入每一个分支，直到不能继续为止，然后回溯到<mark style="background: #FFB86CA6;">最近的分支点</mark>继续探索未访问的路径；
- 数据结构：
- 适用场景：迷宫、数独等
## ⌨️代码实现
- 思路
	1. 为了标记节点的访问情况，可以开设一个数组进行，并且递归调用自身的函数
	2. 也可以用显式的栈，并结合循环
- 🌰数组+递归：
```c
int graph[MAX][MAX];  // 邻接矩阵表示的图
int visited[MAX];     // 记录节点是否被访问过

void DFS(int node, int n) {
    printf("%d ", node);  // 处理当前节点
    visited[node] = 1;    // 标记当前节点为已访问

    for (int i = 0; i < n; i++) {
        if (graph[node][i] == 1 && !visited[i]) {
            DFS(i, n);  // 递归访问所有未访问的邻接节点
        }
    }
}
```
- 🌰显式栈+循环
```c
int graph[MAX][MAX];  // 邻接矩阵表示的图
int visited[MAX];     // 记录节点是否被访问过

void DFS(int startNode, int n) {
    int stack[MAX];
    int top = -1;

    // 将起始节点压入栈
    stack[++top] = startNode;

    while (top != -1) {
        // 从栈中弹出一个节点
        int node = stack[top--];

        // 如果该节点尚未被访问过
        if (!visited[node]) {
            printf("%d ", node);  // 处理当前节点
            visited[node] = 1;    // 标记当前节点为已访问

            // 将该节点的所有未访问的邻接节点压入栈
            for (int i = n - 1; i >= 0; i--) {  // 逆序压栈以保持顺序
                if (graph[node][i] == 1 && !visited[i]) {
                    stack[++top] = i;
                }
            }
        }
    }
}
```
## ❓何时开始回溯
该节点的所有相邻节点都已经访问过或者不符合搜索条件，则需要回溯到前一个节点继续探索其他未访问的路径。

---
## ✨DFS的应用
### 寻找割点和双连通分量
📝<mark style="background: #ADCCFFA6;">基本概念</mark>
- **双连通性（Biconnectivity）**：
	如果一个<mark style="background: #FFF3A3A6;">无向图</mark>在去除任何一个节点（以及与该节点相关的边）后仍然保持连通性，则该图是双连通的（或者说任意一个<mark style="background: #FFF3A3A6;">顶点</mark>存在于<mark style="background: #FFF3A3A6;">至少两个</mark>`连通子图`中）
- **割点 (Articulation Points)**:
	- 如果移除该节点（以及与该节点相关的边）后，图会变得不连通;
	- 割点是使得图断开的关键节点;
	- 寻找割点可以帮助识别图中的脆弱部分。
- **双连通分量（Biconnected Components）**:
	是最大的<mark style="background: #ADCCFFA6;">双连通子图</mark>
		当G是连通的，且不存在`割点`时，G被称为~
- **disc** （DFS编号）：
	- `disc[u]`表示`u`在DFS的遍历中第一次被发现的时间（次序）
- **low** 
	- `low[u]`表示节点`u`在不直接返回父节点、且<mark style="background: #FF5582A6;">从其孩子节点开始</mark>的情况下，可以访问到的最小`disc[v]`
	- 叶子结点的low为自身的disc
	- **递归定义**为:
		- low \[u] = min{disc\[u],min{low(v)|v为u的孩子节点},min{disc\[v]|(u,v)是一条back edge}}
	- 🌰：![Pasted image 20240515104303.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240515104303.png)
💥割点的判断原理
- 对于根节点：至少有两个`child`时，`root`为割点
- 对于非根节点`u`：若存在某个子节点`v`使得，<mark style="background: #FFF3A3A6;">low[v] >= disc[u]</mark>，则`u`为割点
	- 注意这里是子节点，而非子孙节点；
	- 也就是说，子节点中存在 不直接返回`u`而能够返回其祖先的路径
### 欧拉回路
📝相关概念
1. <mark style="background: #ADCCFFA6;">Euler tour</mark>：欧拉通路
	每条边恰好经历一次，连续经过所有的边
		与访问所有顶点的**哈密顿回路**不同
	- ✨<mark style="background: #BBFABBA6;">判断</mark>：奇度点的个数为2，并且必须从其中一个顶点开始遍历；奇度点个数为0
1. <mark style="background: #ADCCFFA6;">Euler curcuit</mark>:  欧拉回路
	在前者的基础上，最后回到原点
	- ✨<mark style="background: #BBFABBA6;">判断</mark>：G为连通的，且
		- 对于无向图，每个顶点具有偶数的`degree`；
		- 对于有向图，顶点的入度均等于出度，且所有顶点处于同一个强连通分量当中
- 详解（有无向的区分）：![Pasted image 20240528234859.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240528234859.png)
### ⌨️寻找强连通分量
✨传送门：[[obsidian/个人知识库/大一/FDS/作业集/HW纠错#Tarjan's\|HW纠错#Tarjan's]]
❓<mark style="background: #BBFABBA6;">什么时候开始从栈中弹出顶点</mark>
	当顶点`v`不存在未访问的邻接顶点时，<mark style="background: #FFF3A3A6;">检查</mark>当前`v`是否为强连通分量的起点
❓<mark style="background: #FFF3A3A6;">起点的检查条件</mark>
此时检验`low[v] == disc[v]`是否成立：如果成立，说明，v的子节点可以在直接返回v的前提下访问回到（且不能再早）地访问回v，构成了强连通分量
	❓<mark style="background: #ADCCFFA6;">正确性的证明</mark>
	✨可以通过递归的方法进行证明：
		1. 假设现在只有$v\leftrightarrow w$ 这两个顶点，如果从v开始DFS，则之后调用DFS(w)，w的邻接顶点为已经访问过的v，更新low\[w].再之后DFS调用结束，回溯到v，根据w的属性更新low\[v]。
		2. 如果我们让disc与low都从0开始，且让v成为一开始的顶点。那么显然从开始回溯时开始检查disc\[x] == low\[x],这对于w时不成立的，因为disc\[w] = 1,而low\[w]=0.而对于`v`来说，这显然成立。因此，从目前的栈顶开始弹出元素，直到弹出v为止。忘记介绍了，当我们DFS时就让顶点入栈（不用担心顶点已经被访问过，因为只有未访问过的顶点才会调用其DFS）
		3. 以上我们证明了对于初始条件，这一判断方式是成立的.接下来假设顶点`v`与一个连通分量`A`构成了强连通分量，即$v\leftrightarrow A$成立。那么，类似于先前的讨论，在`A`中增加一个"$u\leftrightarrow w$"的边，条件依旧成立。因此得证