---
{"dg-publish":true,"permalink":"/obsidian///fds//1-list/","created":"2024-04-23T19:08:23.606+08:00","updated":"2024-09-08T15:25:05.382+08:00"}
---

# 链表
- 加入虚拟的头指针 dummy node可以优化操作
## 普通链表:含哑元头结点的实现
### 结构体
```c
//链表节点结构体
typedef struct ListNode {
    int value;               // 节点存储的数据
    struct ListNode *next;   // 指向下一个节点的指针
} ListNode;

// 链表结构体，包含一个指向dummy head node的指针
typedef struct List {
    ListNode *dummyHead;     // 哑元头结点
} List;
```
### 基本函数
1. 初始化链表
>关键是同时为链表<mark style="background: #FFF3A3A6;">结构体</mark>list以及该结构体成员<mark style="background: #FFF3A3A6;">dummyHead</mark>申请空间
```c
// 初始化链表
List *initList() {
    List *list = malloc(sizeof(List));
    if (list == NULL) {
        return NULL; // 内存分配失败
    }
    ListNode *dummyHead = malloc(sizeof(ListNode));
    if (dummyHead == NULL) {
        free(list);
        return NULL;
    }
    dummyHead->next = NULL; // 初始化时哑元头结点的next指针为空
    list->dummyHead = dummyHead;
    return list;
}
```
2. 添加元素
```c
// 在链表末尾添加元素
void appendToList(List *list, int value) {
    ListNode *newNode = malloc(sizeof(ListNode));
    if (newNode == NULL) {
        return; // 内存分配失败，应该处理错误
    }
    newNode->value = value;
    newNode->next = NULL;

    ListNode *current = list->dummyHead;
    while (current->next != NULL) {
        current = current->next; // 遍历到链表末尾
    }
    current->next = newNode; // 在末尾添加新节点
}
```
3. 删除元素
>关注细节
```c
// 从链表中删除第一个出现的指定值
void removeFromList(List *list, int value) {
    ListNode *current = list->dummyHead;
    //需要找到待删除节点的前驱
    //因此，检查值的时候是current->next->value，直到后继为待删除节点
    while (current->next != NULL && current->next->value != value) {
        current = current->next;
    }
    if (current->next != NULL) {     //如果为NULL说明没有找到指定的元素，不用操作
        ListNode *temp = current->next;  //先用指针指向待删除节点再操作，确保内存释放
        current->next = temp->next;
        free(temp);
    }
}
```
4. 打印链表
```c
// 打印链表中的所有元素
void printList(List *list) {
    ListNode *current = list->dummyHead->next; // 从真正的第一个元素开始打印
    while (current != NULL) {
        printf("%d -> ", current->value);
        current = current->next;
    }
}
```
## 双向循环链表
![Pasted image 20240423191710.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240423191710.png)
### 结构体
```c
// 双向链表节点结构体
typedef struct ListNode {
    int value;
    struct ListNode *prev;
    struct ListNode *next;
} ListNode;

// 双向链表结构体
typedef struct List {
    ListNode *dummyHead;
} List;
```
### 基本函数
1. 初始化
```c
// 初始化双向循环链表
List *initList() {
    List *list = malloc(sizeof(List));
    if (!list) {
        return NULL;
    }
    ListNode *dummyHead = malloc(sizeof(ListNode));
    if (!dummyHead) {
        free(list);
        return NULL;
    }
    dummyHead->value = 0; // 哑元节点的值通常不使用
    dummyHead->next = dummyHead; // 指向自己形成循环
    dummyHead->prev = dummyHead; // 指向自己形成循环
    list->dummyHead = dummyHead;
    return list;
}
```
2. 链表尾部添加新元素
```c
// 在双向循环链表末尾添加元素
void appendToList(List *list, int value) {
    ListNode *newNode = malloc(sizeof(ListNode));
    if (!newNode) {
        return;
    }
    newNode->value = value;

    ListNode *last = list->dummyHead->prev; // 最后一个元素是哑元头结点的前一个

    newNode->next = list->dummyHead; // 新节点的next指向哑元头结点
    newNode->prev = last; // 新节点的prev指向最后一个元素
    last->next = newNode; // 原最后一个元素的next指向新节点
    list->dummyHead->prev = newNode; // 哑元头结点的prev更新为新节点
}
```
3. 删除链表中第一次出现的指定值
```c
// 从双向循环链表中删除第一个出现的指定值
void removeFromList(List *list, int value) {
    ListNode *current = list->dummyHead->next;
    //如果没有找到对应元素，遍历到尾节点之后会回到dummyHead
    while (current != list->dummyHead && current->value != value) {
        current = current->next;
    }
    if (current != list->dummyHead) { // 没有回到dummyHead表示找到了相应的节点
        current->prev->next = current->next;
        current->next->prev = current->prev;
        free(current);
    }
}
```
4. 打印链表的值
```c
// 打印双向循环链表中的所有元素
void printList(List *list) {
    ListNode *current = list->dummyHead->next;
    while (current != list->dummyHead) {     //避免进入无限循环
        printf("%d <-> ", current->value);
        current = current->next;
    }
    printf("Repeat to head\n");
}
```
## 多项式计算的运用
### 结构体
>无需给出多项式链表的定义
```c
#include <stdio.h>
#include <stdlib.h>

// 多项式的节点结构体
typedef struct PolyNode {
    int coef; // 系数
    int exp;  // 指数
    struct PolyNode *next;
} PolyNode;
```
### 多项式创建
```c
PolyNode* createPolyNode(int coef, int exp) {
    PolyNode *node = (PolyNode *)malloc(sizeof(PolyNode));
    node->coef = coef;
    node->exp = exp;
    node->next = NULL;
    return node;
}

//根据给出的系数与指数创建PolyNode并插入到多项式链表的合适位置
PolyNode* insertPolyNode(PolyNode* head, int coef, int exp) {
	
	//运用了生成多项式节点的函数
    PolyNode *newNode = createPolyNode(coef, exp);
    
    //将新节点置为头结点有两种可能：
	//还没有存在头结点（多项式链表为空）/新节点的指数最大
    if (head == NULL || exp > head->exp) {
        newNode->next = head;
        head = newNode;
    } else {
        PolyNode *current = head;
        
        //注意，为了找到合适的位置，用current->next>exp进行比较
        while (current->next != NULL && current->next->exp > exp) {
            current = current->next;
        }
        newNode->next = current->next;
        current->next = newNode;
    }
    return head;
}

//根据给出的多项式项数和后序的输入来创建多项式链表
PolyNode* createPoly() {
    PolyNode *head = NULL;
    int n, coef, exp;
    printf("Enter number of terms: ");
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        printf("Enter coef and exp: ");
        scanf("%d %d", &coef, &exp);
        head = insertPolyNode(head, coef, exp);
    }
    return head;
}

```
### 多项式相加
```c
PolyNode* addPoly(PolyNode* p1, PolyNode* p2) {
    PolyNode *result = NULL;
    while (p1 != NULL && p2 != NULL) {
	    //比较系数，将较大的一项导入到新的链表中（给出系数与指数）
        if (p1->exp > p2->exp) {
            result = insertPolyNode(result, p1->coef, p1->exp);
            p1 = p1->next;
        } else if (p1->exp < p2->exp) {
            result = insertPolyNode(result, p2->coef, p2->exp);
            p2 = p2->next;
        } else {
            int sum = p1->coef + p2->coef;
            if (sum != 0) { //如果为0，也不需要插入到新链表中
                result = insertPolyNode(result, sum, p1->exp);
            }
            p1 = p1->next;
            p2 = p2->next;
        }
    }
    
    //如果一个链表为空，将剩余的非空链表的剩余节点都复制到新的链表中
    while (p1 != NULL) {
        result = insertPolyNode(result, p1->coef, p1->exp);
        p1 = p1->next;
    }
    while (p2 != NULL) {
        result = insertPolyNode(result, p2->coef, p2->exp);
        p2 = p2->next;
    }
    return result;
}
```

### 打印多项式
```c
void printPoly(PolyNode* head) {
    if (head == NULL) {
        printf("0\n");
        return;
    }
    for (PolyNode *current = head; current != NULL; current = current->next) {
        printf("%d*x^%d", current->coef, current->exp);
        
        //判断下一个节点是否为空，避免行末存在多余的+
        if (current->next != NULL)
            printf(" + ");
    }
    printf("\n");
}
```
