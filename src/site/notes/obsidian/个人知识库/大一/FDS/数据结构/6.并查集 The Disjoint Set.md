---
{"dg-publish":true,"permalink":"/obsidian///fds//6-the-disjoint-set/","created":"2024-04-10T10:33:35.260+08:00","updated":"2024-09-08T15:25:05.398+08:00"}
---

# 引言
<mark style="background: #ADCCFFA6;">等价关系</mark>
1. 自反性 reflexive：$aRa$
2. 对称性 symmetric
3. 传递性 transitive
# ADT
## <mark style="background: #BBFABBA6;">Find</mark>
1. 目的：
	查找给定元素所在的集合的代表元素（通常是集合的根节点）；
	该操作用于确定两个元素是否位于同一个集合中。
2. 输入：
	一个元素
3. 输出：
	该元素所在集合的代表元素
## <mark style="background: #BBFABBA6;">Union</mark>
1. 目的：
	1. 合并操作，用于将两个元素所在的集合合并为一个集合；
	2. 如果两个元素已经在同一个集合中，则不进行任何操作
2. 输入:
	Union($a$,$b$) 并且默认将b指向a
3. 输出：
	不返回任何输出，但会将两个集合合并为一个
# 函数实现
>通常将Union与Find作为整体 来分析时间复杂度
## <mark style="background: #BBFABBA6;">Smart Way</mark>
>Union-by-size实现
- 代码 
```c
// parent数组用于存储每个元素的父节点或集合大小（负值）
int parent[N]; //将数组作为全局变量，使得Find函数不需要每次传入数组

// 初始化并查集
void initialize() {
    for(int i = 0; i < N; i++) {
        parent[i] = -1; // 每个元素的父节点初始化为-1，表示每个集合的大小为1
    }
}

// 查找元素x的根节点
int find(int x) {
    if (parent[x] < 0) {
        return x;
    } else {
        return parent[x] = find(parent[x]); // 路径压缩
    }
}

// 按大小合并x和y所在的集合
void unionBySize(int x, int y) {
    int rootX = find(x);
    int rootY = find(y);

    if (rootX != rootY) {
        // 如果x的集合大小大于y的集合，将y合并到x中
        if (parent[rootX] <= parent[rootY]) {
            parent[rootX] += parent[rootY]; // 更新x的集合大小
            parent[rootY] = rootX;
        } else {
            parent[rootY] += parent[rootX]; // 更新y的集合大小
            parent[rootX] = rootY;
        }
    }
}
```


## <mark style="background: #BBFABBA6;">路径压缩</mark>
1. 含义
	1. 用于减少查找根节点时的时间复杂度
	2. 确保每个节点直接指向其根节点
2. 代码（递归）
```c
// 查找元素x的根节点
int find(int x) {
    if (parent[x] < 0) {
        return x;
    } else {
        return parent[x] = find(parent[x]); // 路径压缩
    }
}
```
```c
//另解
SetType  Find ( ElementType  X, DisjSet  S )

{   ElementType  root,  trail,  lead;

    for ( root = X; S[ root ] > 0; root = S[ root ] )
        ;  /* find the root */
      
    for ( trail = X; trail != root; trail = lead ) {
       lead = S[ trail ] ;  
       S[ trail ] = root ;  
    }  /* collapsing */

    return  root ;
}
```