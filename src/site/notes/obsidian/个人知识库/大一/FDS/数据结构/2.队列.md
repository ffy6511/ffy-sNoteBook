---
{"dg-publish":true,"permalink":"/obsidian///fds//2/","created":"2024-04-08T19:06:08.221+08:00","updated":"2024-09-08T15:25:05.383+08:00"}
---

# 1.循环队列—确定容量
## 1.结构与基本函数
### 1.1结构体
```c
typedef struct {
	int* elements;
	int front;
	int rear;
	int capacity;
}circularQueue;	
```
### 1.2初始化循环队列
```c
CircularQueue* InitQueue(int capacity) {
	CircularQueue* q = (CircularQueue*)malloc(sizeof(CircularQueue));
	q->val = (int*)malloc(sizeof(int) * capacity);
	q->front = q->rear = 0;
	return q;
}
```
### 1.3判断队列情况
```c
//判断队列是否为空
int IsEmpty(CircularQueue* q) {
	return q->front == q->rear;
}
//判断队列是否为满
int IsFull(CircularQueue* q) {
	return (q->rear + 1) % q->capacity == q->front;
}
```
### 1.4入队和出队
```c
//入队
void EnQueue(int x, CircularQueue* q) {
	if (IsFull(q))
		printf("The queue if full!\n");
	q->val[q->rear] = x;
	q->rear = (q->rear + 1) % q->capacity;
}

//出队
int Dequeue(CircularQueue* q) {
	if (IsEmpty(q)) {
		printf("The queue is empty!\n");
		return -1;
	}
	int x = q->val[q->front];
	q->front = (q->front + 1) % q->capacity;
	return x;
}
```
### 1.5获取队首元素
```c
nt Peek(circularQueue* Q)
{
	if (!isEmpty(Q)) {
		return Q->elements[Q->front];
	}
	else {
		printf("Queue is empty!\n");
		return -1;
	}
}
```
### 1.6释放内存
```c
void freeQueue(circularQueue* Q)
{
	free(Q->elements); //先释放结构体中的数组的内存
	free(Q);          //再释放指向结构体的指针的内存
}
```
## 2.对已知节点总数的树进行层序遍历
### 2.1结构体定义
```c
typedef struct {
    TreeNode** elements;
    int front; // 队头指针
    int rear; // 队尾指针，初始设置为0
    int size; // 队列当前元素数量
    int capacity; // 队列容量
} Queue;
```
### 2.2初始化队列
```c
Queue* CreatQueue(int capacity) {
	Queue* q=(Queue*)malloc(sizeof(Queue)); 
    q->elements = (TreeNode**)malloc(sizeof(TreeNode*)*capacity);
    if(q->elements == NULL){
	    printf("Out of Space!\n");
	    return -1;
	}
    q->front = q->rear =q->size =0;
    q->capacity = capacity;
    return q;
}
```
### 2.3入队与出队（与前近似）
```c
void enqueue(Queue* q, TreeNode* node) {
    if(IsFull(q)){
		printf("The queue is full!\n");
		return;
	}
	q->elements[q->rear] = node;
	q->rear = (q->rear+1) % q->capacity;
	q->size+=1;
}

// 出队操作
TreeNode* dequeue(Queue* q) {
    if(IsEmpty(q)){
	    printf("The queue is empty!\n");
	    return NULL;
    }
    TreeNode* node = q->elements[q->front];
    q->front = (q->front+1) % q->capacity;
    q->size-=1;
    return node;
}
```
### 2.4判断队列情况
```c
//检查是否为空
int IsEmpty(Queue* q) {
    return q->size == 0;
}

//检查是否为满
int IsFull(Queue* q){
	return q->size == q-> capacity;
}
```
### 2.5完全二叉树的层序遍历
```c
void levelOrderTraversal(TreeNode* root, int nodeCount) {
    if (!root) return; // 如果树为空，则不进行操作

    Queue* queue = createQueue(nodeCount); // 根据节点总数创建队列
    enqueue(queue, root); // 将根节点加入队列

    while (!isEmpty(queue)) {
        TreeNode* current = dequeue(queue);
        printf("%d ", current->value); // 访问当前节点

        if (current->left) enqueue(queue, current->left); // 左子节点入队
        if (current->right) enqueue(queue, current->right); // 右子节点入队
    }

    freeQueue(queue); // 遍历完成后释放队列
}

```
### 2.6应用的模拟实现
```c
int main() {
    int tree[] = {1, 2, 3, 4, 5, 6, 7}; // 示例完全二叉树
    int n = sizeof(tree) / sizeof(tree[0]);
    
    printf("Level Order Traversal: ");
    levelOrderTraversal(tree, n);
    return 0;
}
```
# 链表实现—不确定容量
## 1.链表结构与函数
### 1.1结构体
```c
//节点的结构体定义
typedef struct QueueNode {
	int data;
	struct QueueNode* next;
}QueueNode;

typedef struct Queue {
    QueueNode *front, *rear;
    int size;
} Queue;
```
### 1.2初始化链表队列
```c
//主函数中先为Q动态分配内存，然后Initialize(Q);
void InitializeQueue(Queue* Q) {
	Q->front = Q->rear = NULL;
}
```
### 1.3判断队列是否为空
```c
//检查队列是否为空(链表可无限延展)
int IsEmpty(Queue* Q) {
	return Q->front == NULL;
}
```
### 1.4入队和出队
```c
//入队操作
void Enqueue(int val, Queue* Q) {
	QueueNode* newNode = (QueueNode*)malloc(sizeof(QueueNode));
	if (newNode == NULL) {
		printf("Out of space!\n");
	}newNode->data = val;
	newNode->next = NULL;

	if (IsEmpty(Q)) {
		// 如果队列为空，新节点既是队首也是队尾
		Q->front = Q->rear = newNode;
	}
	else {
		// 否则，添加到队尾，并更新队尾指针
		Q->rear->next = newNode;
		Q->rear = newNode;
	}
}

//出队操作
int Dequeue(Queue* Q) {
	if (IsEmpty) {
		printf("Queue is empty!\n");
		return -1;
	}
	QueueNode* tmpNode = Q->front;
	int data = tmpNode->data;
	Q->front = Q->front->next;

	if (Q->front == NULL) {
		// 如果队列变空，更新队尾为 NULL
		Q->rear = NULL;
	}
	free(tmpNode);
	return data;
}
```
### 1.5释放内存
```c
//利用循环与出队的操作
void FreeQueue(Queue* Q) {
	while (!IsEmpty(Q)) {
		Dequeue(Q);
	}
	free(Q);
}
```