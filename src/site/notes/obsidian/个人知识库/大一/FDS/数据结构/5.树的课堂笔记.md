---
{"dg-publish":true,"permalink":"/obsidian///fds//5/","created":"2024-03-23T19:54:48.989+08:00","updated":"2024-09-08T15:25:05.385+08:00"}
---

# 1.二叉树
## ①遍历相关的代码
### 前序遍历
### 中序遍历打印数据
```c
// 中序遍历二叉树并打印数据
void inorderTraversal(TreeNode* root) {
    if (root != NULL) {
        inorderTraversal(root->left);  // 遍历左子树
        printf("%d ", root->data);     // 访问根节点
        inorderTraversal(root->right); // 遍历右子树
    }
}
```
### 利用**后序遍历**计算树的高度
```c
int Height (Binary T)
{
	if(T == NULL){
		return -1;
	}
	else 
		return 1+Max(Height (T->left),Height(T->right));
}
```
## ②由中序遍历和后序遍历的结果构建二叉树
## ③基础操作相关
### 3.1结构体
```c
typedef struct TreeNode
{
	int value;
	struct TreeNode *left;
	struct TreeNode *right;
}TreeNode;

typedef TreeNode *BinaryTree;
```
### 3.2二叉树节点的创建
```c
BinaryTree creatNode(int value)
{
	BinaryTree node = malloc(sizeof(TreeNode));
	node->value = value;
	node->left = NULL;
	node->right = NULL;
	return node;
}
```
# 2. 二叉查找树
## ①定义
### 整体的介绍
- 节点的值不一定为不相等的值（可以比较大小即可）
- 左子树的元素都比右子树的元素小(根节点的值位于两者之间)
- 每个子树都是二叉查找树
- 平均深度为O(logN)
### 有关索引的介绍
- 一般来说，根节点的索引为0；
- 一般来说，父节点索引为i时，左子树的索引为2i+1,右子树的索引为2i+2
## ②基本功能的代码实现
### 2.1 节点
```c
struct TreeNode;
typedef struct TreeNode *Position;
typedef struct TreeNode *SearchTree;

struct TreeNode
{
	EleType Element;
	SearchTree Left;
	SearchTree Right;
}
```
### 2.2 Find
```c
//递归实现的查找
Position Find(EleType X,SearchTree T)
{
	if(T == NULL)
		return NULL;
	if(X < T->Element)
		return Find(X,T->Left);
	else if(X > T->Element)
		return Find(X,T->Right);
	else
		return T;
}
```
```c
//将递归转化为循环的版本
Position Find(EleType X,SearchTree T)
{
	while(T){
		if(X == T->Element)
			return T;
		else if(X > T->Element)
			T = T->Right;
		elsee
			T  = T->Left;
	}
}
```
- T(N)=S(N)=O(d) ,where d is the depth of the X.
```c
//FindMin 查找最小值的递归版本
Position FindMin(SearchTree T)
{
	if(T == NULL)
		return NULL;
	else if(T->Left == NULL)
		return T;
	else 
		return FindMin()
}
```
```
//Findmax 查找最大值的循环版本
Position FindMax(SearchTree T)
{
	if(T){
		while(T->Right){
			T = T->Right;
		}
		return T;
	}
}
```
### 2.3 *Insert* (x)
- 思路
	先查找一下待插入的元素是否在二叉查找树中
	如果不在树中，插入指定位置
	需要找到在“查找”过程中的非空节点，将其作为插入元素的父节点
```c
SearchTree Insert(EleType X,SearchTree T)
{
	if(T==NULL)
	{
		T = malloc(sizof(struct TreeNode));
		if(T==NULL)
			FatalError("Out of space!");
		else
		{
			T->Element = X ;
			T->Left = T->Right = NULL;
			return T;
		}
	}
	else{
		if(T->Element > X)
			T->Left = Insert(X,T->Left);
		else
			T->Right = nsert(X,T->Right);
	}
}
```
>注意此处需要返回T，否则新建立的节点无法链接到已有的树当中；
### 2.4 *Delete*
- 思路
	从最简单的情况（度为0的叶子节点）开始讨论：直接free
		度为1：将待删除节点被父节点指向的指针，指向待删除节点的下一个节点![81a1442b76cef63a10d6d4f1964889a 1.jpg](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/81a1442b76cef63a10d6d4f1964889a%201.jpg)
#### 2.4.1 递归实现的真正删除
```c
SearchTree Delete(EleType X,SearchTree T)
{
	Position TmpCell;
	if(T == NULL)
		Error("Element not found");
	else if (X < T->Element)
		T->Left = Delete(X,T->Left);
	
}
```

#### 2.4.2 懒惰删除
含义：
	当想要删除元素时，只是做一个被删除的记号
### 2.5 树的建立
```c
SearchTree creatBST(int element)
{
	struct TreeNode* newTree = (SearchTree)malloc(sizeof(struct TreeNode));
	if (newTree == NULL) {
		printf("Failed to cread newBST!\n");
		return NULL;
	}
	newTree->element = element;
	newTree->Left = NULL;
	newTree->Right = NULL;
	return newTree;
}
```
#### ①已知**层序遍历**的结果 实现BST的生长

# 3.完全二叉树
## 3.1 定义
- 层级填满
	除了最后一层，每一层均被完全填满
- 最后一层从左到右填充
## 3.2 特点
### ①**叶子节点**的寻找
- 根节点的索引为0时：$\left\lfloor \frac{n}{2} \right\rfloor$ 到 ($n$-1)
- 根节点的**索引为1**时：$\left\lfloor \frac{n}{2} \right\rfloor+1$ 到$n$
	**证明**：(根从0开始)
	![Pasted image 20240408120046.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240408120046.png)
	

### ②**索引关系**
- 根节点的索引为0时，满足：
对于任意一个索引为i的节点，它的左子树的节点为$2i+1$，右子树的节点为$2i+2$
- ~为1时，满足：
	$2i$与$2i+1$
