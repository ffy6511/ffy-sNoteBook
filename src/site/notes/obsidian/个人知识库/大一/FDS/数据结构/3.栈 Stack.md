---
{"dg-publish":true,"permalink":"/obsidian///fds//3-stack/","created":"2024-04-23T19:51:46.031+08:00","updated":"2024-09-08T15:25:05.391+08:00"}
---

s- 先进后出的线性表
# Stack的具体实现
## 数组实现
>操作简单，但是要求预先设定内存的上限
```c
#define MAXSIZE 100  // 定义栈的最大容量

// 栈的结构体定义
typedef struct {
    int items[MAXSIZE];
    int top;
} Stack;

// 初始化栈
void initStack(Stack *s) {
    s->top = -1;
}

// 检查栈是否为空
int isEmpty(Stack *s) {
    return s->top == -1;
}

// 检查栈是否满
int isFull(Stack *s) {
    return s->top == MAXSIZE - 1;
}

// 入栈操作
void push(Stack *s, int item) {
    if (isFull(s)) {
        printf("Stack is full!\n");
    } else {
        s->items[++s->top] = item;
    }
}

// 出栈操作
int pop(Stack *s) {
    if (isEmpty(s)) {
        printf("Stack is empty!\n");
        return -1;  // 返回一个错误值
    } else {
        return s->items[s->top--];
    }
}

// 获取栈顶元素
int peek(Stack *s) {
    if (!isEmpty(s)) {
        return s->items[s->top];
    } else {
        printf("Stack is empty!\n");
        return -1;  // 返回一个错误值
    }
}
```
## 链表实现
>提供更灵活的内存使用
```c
// 链表节点的结构体定义
typedef struct Node {
    int data;
    struct Node* next;
} Node;

// 栈的结构体定义，包含指向栈顶的指针
typedef struct {
    Node* top;
} Stack;

// 初始化栈
void initStack(Stack *s) {
    s->top = NULL;
}

// 检查栈是否为空
int isEmpty(Stack *s) {
    return s->top == NULL;
}

// 入栈操作
void push(Stack *s, int item) {
    Node* newNode = (Node*) malloc(sizeof(Node));
    if (newNode == NULL) {
        printf("Unable to allocate memory.\n");
        return;
    }
    newNode->data = item;
    
    //为了实现后进先出，采用头插法，将新节点作为头节点
    newNode->next = s->top;
    s->top = newNode;
}

// 出栈操作
int pop(Stack *s) {
    if (isEmpty(s)) {
        printf("Stack is empty!\n");
        return -1; // 返回一个错误值
    } else {
	    
	    //由于新节点总是头结点，弹出头结点可以实现后进先出
        Node* temp = s->top;
        int popped = temp->data;
        s->top = temp->next;//更新头结点
        free(temp);
        return popped;
    }
}

// 获取栈顶元素
int peek(Stack *s) {
    if (!isEmpty(s)) {
        return s->top->data;
    } else {
        printf("Stack is empty!\n");
        return -1; // 返回一个错误值
    }
}
```
# Stack在运算方面的运用
- 单词：
	- operand 操作数
	- operator 操作符
## <mark style="background: #BBFABBA6;">中缀转后缀</mark>
>参考资料:https://blog.csdn.net/weixin_44162361/article/details/116170947
1. 原因：计算机处理后缀表达式更加方便
2. 栈的运用
	1. operand的顺序不变
	2. operator按优先级<mark style="background: #FFF3A3A6;">从高到低</mark>进行输出（栈内的优先级高/等则弹出）
		1. 故顺序改变，需要入栈
3. 步骤（**左往右**扫描）![Pasted image 20240423201623.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240423201623.png)![Pasted image 20240423201546.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240423201546.png)
4. 优先级![Pasted image 20240423201634.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240423201634.png)
5. 补充：
	1. 幂的引入![Pasted image 20240423204858.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240423204858.png)
## <mark style="background: #BBFABBA6;">中缀转前缀</mark>
1. **栈的运用**
	1. 创建两个栈，分别用来暂存符号与答案
	2. 当第一个栈的操作符均被弹出后，暂存答案的栈依次弹出的结果就是前缀
2. **步骤**（<mark style="background: #FFB86CA6;">右往左</mark>扫描）：![Pasted image 20240423203121.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240423203121.png)
3. 举例
	1. 操作数总是如S2，操作符加入S1
	2. 当S1当前栈顶的优先级较高或相等（同转后缀）则弹出到S2栈顶；否则压入当前优先级较高的操作符
	3. 如果碰到了 ( ,直接压入（优先级最高）；碰到)则直接弹出(前的所有操作符到S2
	4. 当中缀表达式扫描结束时，将S1剩余的操作符依次弹入到S2的栈顶
	5. 依次弹出S2栈顶的元素，得到的结果就是所求的前缀表达式
	详见:https://blog.csdn.net/zm_miner/article/details/115329977
## <mark style="background: #BBFABBA6;">计算后缀表达式</mark>
1. 步骤(从左到右扫描)
	1. 构建栈，将操作数均压入栈顶
	2. 碰到操作符则，依次弹出栈顶元素，并将<mark style="background: #FF5582A6;">后弹出</mark>的作<mark style="background: #FF5582A6;">为前</mark>操作数；![Pasted image 20240423204629.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240423204629.png)
		1. 计算结果之后，将所得结果压入栈顶
	3. 递归完成上述步骤，直至扫描结束，此时栈内元素就是结果
