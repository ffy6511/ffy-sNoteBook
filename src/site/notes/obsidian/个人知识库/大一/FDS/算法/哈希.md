---
{"dg-publish":true,"permalink":"/obsidian///fds///","created":"2024-06-12T10:31:02.584+08:00","updated":"2024-09-08T15:25:05.404+08:00"}
---

# 🌰哈希表实现
## 简单的实现
>采取开放地址寻址法，且：哈希函数为简单的取模、解决冲突的函数为f(i) = i
```c
#include <stdio.h>
#include <stdlib.h>

#define TABLE_SIZE 10
#define EMPTY -1

typedef struct {
    int key;
    int value;
} HashEntry;

typedef struct {
    HashEntry* table;
    int size;
} HashTable;

HashTable* create_table(int size) {
    HashTable* hashTable = (HashTable*)malloc(sizeof(HashTable));
    hashTable->size = size;
    hashTable->table = (HashEntry*)malloc(sizeof(HashEntry) * size);
    for (int i = 0; i < size; i++) {
        hashTable->table[i].key = EMPTY;
        hashTable->table[i].value = 0;
    }
    return hashTable;
}

int hash(int key, int size) {
    return key % size;
}

void insert(HashTable* hashTable, int key, int value) {
    int index = hash(key, hashTable->size);
    while (hashTable->table[index].key != EMPTY) {
        index = (index + 1) % hashTable->size;
    }
    hashTable->table[index].key = key;
    hashTable->table[index].value = value;
}

int search(HashTable* hashTable, int key) {
    int index = hash(key, hashTable->size);
    while (hashTable->table[index].key != EMPTY) {
        if (hashTable->table[index].key == key) {
            return hashTable->table[index].value;
        }
        index = (index + 1) % hashTable->size;
    }
    return EMPTY; // Key not found
}

void delete(HashTable* hashTable, int key) {
    int index = hash(key, hashTable->size);
    while (hashTable->table[index].key != EMPTY) {
        if (hashTable->table[index].key == key) {
            hashTable->table[index].key = EMPTY;
            hashTable->table[index].value = 0;
            return;
        }
        index = (index + 1) % hashTable->size;
    }
}

void print_table(HashTable* hashTable) {
    for (int i = 0; i < hashTable->size; i++) {
        if (hashTable->table[i].key != EMPTY) {
            printf("Index %d: Key = %d, Value = %d\n", i, hashTable->table[i].key, hashTable->table[i].value);
        } else {
            printf("Index %d: Empty\n", i);
        }
    }
}

void free_table(HashTable* hashTable) {
    free(hashTable->table);
    free(hashTable);
}
```
`key` 是关键字，也就是要插入的数据；
`value`是根据
# 解决二次聚集的策略
## 双散列
## 再散列
