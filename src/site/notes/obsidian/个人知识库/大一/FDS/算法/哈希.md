---
{"dg-publish":true,"permalink":"/obsidian///fds///","created":"2024-06-12T10:31:02.584+08:00","updated":"2024-09-08T15:25:05.404+08:00"}
---

# ğŸŒ°å“ˆå¸Œè¡¨å®ç°
## ç®€å•çš„å®ç°
>é‡‡å–å¼€æ”¾åœ°å€å¯»å€æ³•ï¼Œä¸”ï¼šå“ˆå¸Œå‡½æ•°ä¸ºç®€å•çš„å–æ¨¡ã€è§£å†³å†²çªçš„å‡½æ•°ä¸ºf(i) = i
```c
#include <stdio.h>
#include <stdlib.h>

#define TABLE_SIZE 10
#define EMPTY -1

typedef struct {
    int key;
    int value;
} HashEntry;

typedef struct {
    HashEntry* table;
    int size;
} HashTable;

HashTable* create_table(int size) {
    HashTable* hashTable = (HashTable*)malloc(sizeof(HashTable));
    hashTable->size = size;
    hashTable->table = (HashEntry*)malloc(sizeof(HashEntry) * size);
    for (int i = 0; i < size; i++) {
        hashTable->table[i].key = EMPTY;
        hashTable->table[i].value = 0;
    }
    return hashTable;
}

int hash(int key, int size) {
    return key % size;
}

void insert(HashTable* hashTable, int key, int value) {
    int index = hash(key, hashTable->size);
    while (hashTable->table[index].key != EMPTY) {
        index = (index + 1) % hashTable->size;
    }
    hashTable->table[index].key = key;
    hashTable->table[index].value = value;
}

int search(HashTable* hashTable, int key) {
    int index = hash(key, hashTable->size);
    while (hashTable->table[index].key != EMPTY) {
        if (hashTable->table[index].key == key) {
            return hashTable->table[index].value;
        }
        index = (index + 1) % hashTable->size;
    }
    return EMPTY; // Key not found
}

void delete(HashTable* hashTable, int key) {
    int index = hash(key, hashTable->size);
    while (hashTable->table[index].key != EMPTY) {
        if (hashTable->table[index].key == key) {
            hashTable->table[index].key = EMPTY;
            hashTable->table[index].value = 0;
            return;
        }
        index = (index + 1) % hashTable->size;
    }
}

void print_table(HashTable* hashTable) {
    for (int i = 0; i < hashTable->size; i++) {
        if (hashTable->table[i].key != EMPTY) {
            printf("Index %d: Key = %d, Value = %d\n", i, hashTable->table[i].key, hashTable->table[i].value);
        } else {
            printf("Index %d: Empty\n", i);
        }
    }
}

void free_table(HashTable* hashTable) {
    free(hashTable->table);
    free(hashTable);
}
```
`key` æ˜¯å…³é”®å­—ï¼Œä¹Ÿå°±æ˜¯è¦æ’å…¥çš„æ•°æ®ï¼›
`value`æ˜¯æ ¹æ®
# è§£å†³äºŒæ¬¡èšé›†çš„ç­–ç•¥
## åŒæ•£åˆ—
## å†æ•£åˆ—
