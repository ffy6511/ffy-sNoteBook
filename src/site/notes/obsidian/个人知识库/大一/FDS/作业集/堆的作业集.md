---
{"dg-publish":true,"permalink":"/obsidian///fds///","created":"2024-04-08T17:19:34.893+08:00","updated":"2024-09-08T15:25:05.378+08:00"}
---

# 1.函数题
## 1.实现指定索引的上浮与下沉
### 1.1 上浮
```c
void PercolateUp(MinHeap* heap, int index) {
	if (index <1 || index > heap->size) {
		printf("Invalid input!\n");
		return;
	}	
	while (index > 1 && heap->val[index / 2] > heap->val[index]) {
		swap(&heap->val[index / 2], &heap->val[index]);
		index /= 2;
	}
}
```
### 1.2 下沉
```c
void PercolateDown(MinHeap* heap, int index) {
	if (index < 1 || index > heap->size) {
		printf("Invalid Input!\n");
		return;
	}
	int child;
	while (2 * index <= heap->size) {
		child = 2 * index;
		if (child < heap->size && heap->val[child + 1] < heap->val[child])
			child++;
		if (heap->val[index] > heap->val[child]) {
			swap(&heap->val[index], &heap->val[child]);
			index = child;
		}
		else
			break;
	}
}
```
## 2.由简单函数实现的插入和删除
### 2.1插入--上浮
```c
void Insert( ElementType X, PriorityQueue H ) 
{
    int p = ++H->Size;
    H->Elements[p] = X;
    PercolateUp( p, H );
}
```
### 2.2 删除Min--下沉
```c
ElementType DeleteMin( PriorityQueue H ) 
{ 
    ElementType MinElement; 
    MinElement = H->Elements[1];
    H->Elements[1] = H->Elements[H->Size--];
    PercolateDown( 1, H );
    return MinElement; 
}
```

# 2.编程题
## 2.1CBT->BST
### 思路
1. **确定树的形状**
	由于BST的中序遍历结果是按照元素值递增的顺序，数组排序后的结果即为BST的中序遍历序列；
	```c
  // 构建完全二叉树的框架，不考虑节点具体值
TreeNode** BuildCBT(int* arr, int n) {
    TreeNode** nodes = (TreeNode**)malloc(n * sizeof(TreeNode*)); // 分配节点指针数组
    for (int i = 0; i < n; i++) {
        nodes[i] = CreatNode(0); // 创建节点，初始值为0
    }
    for (int i = 0; i < n; i++) {
        if (2 * i + 1 < n) nodes[i]->left = nodes[2 * i + 1]; // 设置左子节点
        if (2 * i + 2 < n) nodes[i]->right = nodes[2 * i + 2]; // 设置右子节点
    }
    return nodes;
}
	```
2. **填充节点的值**
	通过递归分配数组中间的元素作为根节点；
	对左半部分和右半部分分别递归同样的操作，以此构建左子树和右子树
	```c
// 通过中序遍历的方式填充树的值
void InorderFillValues(TreeNode* node, int* arr, int* index) {
    if (node == NULL) return; // 如果节点为空，则返回
    InorderFillValues(node->left, arr, index); // 递归填充左子树
    node->val = arr[(*index)++]; // 设置节点值，并移动数组索引
    InorderFillValues(node->right, arr, index); // 递归填充右子树
}
	```
### 代码实现（CBT->BST  并 输出层序遍历的结果）
```c
#include <stdio.h>
#include <stdlib.h>

// 定义二叉树节点的结构体
typedef struct TreeNode {
    int val; // 节点值
    struct TreeNode* left; // 左子节点指针
    struct TreeNode* right; // 右子节点指针
} TreeNode;

// 定义队列结构体，用于层序遍历
typedef struct {
    TreeNode** elements; // 存储队列元素的数组
    int front; // 队列的头指针
    int rear; // 队列的尾指针
    int size; // 队列当前的元素数量
    int capacity; // 队列的最大容量
} Queue;

// 函数原型声明
TreeNode* CreatNode(int val);
void BubbleSort(int* arr, int n);
TreeNode** BuildCBT(int* arr, int n);
void InorderFillValues(TreeNode* node, int* arr, int* index);
void LevelOrderTraversal(TreeNode* root, int n);
Queue* CreatQueue(int capacity);
void Enqueue(Queue* q, TreeNode* node);
TreeNode* Dequeue(Queue* q);
void FreeQueue(Queue* q);

int main() {
    int n; // 存储用户输入的节点数
    scanf("%d", &n);
    int* arr = (int*)malloc(n * sizeof(int)); // 动态分配数组存储节点值
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]); // 读取节点值
    }

    BubbleSort(arr, n); // 对节点值进行冒泡排序

    TreeNode** nodes = BuildCBT(arr, n); // 构建完全二叉树框架
    int index = 0;
    InorderFillValues(nodes[0], arr, &index); // 中序遍历填充树的值

    LevelOrderTraversal(nodes[0], n); // 执行层序遍历并打印结果

    // 释放内存资源
    free(arr);
    free(nodes);
    return 0;
}

// 创建一个新的TreeNode节点
TreeNode* CreatNode(int val) {
    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode)); // 分配内存
    node->val = val; // 设置节点值
    node->left = NULL; // 初始化左子节点为空
    node->right = NULL; // 初始化右子节点为空
    return node;
}

// 使用冒泡排序算法对数组进行排序
void BubbleSort(int* arr, int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp; // 交换元素
            }
        }
    }
}

// 构建完全二叉树的框架，不考虑节点具体值
TreeNode** BuildCBT(int* arr, int n) {
    TreeNode** nodes = (TreeNode**)malloc(n * sizeof(TreeNode*)); // 分配节点指针数组
    for (int i = 0; i < n; i++) {
        nodes[i] = CreatNode(0); // 创建节点，初始值为0
    }
    for (int i = 0; i < n; i++) {
        if (2 * i + 1 < n) nodes[i]->left = nodes[2 * i + 1]; // 设置左子节点
        if (2 * i + 2 < n) nodes[i]->right = nodes[2 * i + 2]; // 设置右子节点
    }
    return nodes;
}

// 通过中序遍历的方式填充树的值
void InorderFillValues(TreeNode* node, int* arr, int* index) {
    if (node == NULL) return; // 如果节点为空，则返回
    InorderFillValues(node->left, arr, index); // 递归填充左子树
    node->val = arr[(*index)++]; // 设置节点值，并移动数组索引
    InorderFillValues(node->right, arr, index); // 递归填充右子树
}

// 创建一个队列，用于层序遍历
Queue* CreatQueue(int capacity) {
    Queue* q = (Queue*)malloc(sizeof(Queue)); // 分配队列结构体内存
    q->elements = (TreeNode**)malloc(capacity * sizeof(TreeNode*)); // 分配队列元素数组内存
    q->front = 0;
    q->rear = 0;
    q->size = 0;
    q->capacity = capacity;
    return q;
}

// 向队列中添加一个元素
void Enqueue(Queue* q, TreeNode* node) {
    if (q->size == q->capacity) return; // 如果队列已满，则不添加
    q->elements[q->rear] = node; // 将节点添加到队尾
    q->rear = (q->rear + 1) % q->capacity; // 循环队列更新队尾位置
    q->size++; // 队列大小增加
}

// 从队列中取出一个元素
TreeNode* Dequeue(Queue* q) {
    if (q->size == 0) return NULL; // 如果队列为空，则返回NULL
    TreeNode* node = q->elements[q->front]; // 取出队头元素
    q->front = (q->front + 1) % q->capacity; // 循环队列更新队头位置
    q->size--; // 队列大小减少
    return node;
}

// 层序遍历二叉树并打印节点值
void LevelOrderTraversal(TreeNode* root, int n) {
    Queue* q = CreatQueue(n); // 创建足够大的队列
    Enqueue(q, root); // 将根节点加入队列
    while (q->size > 0) { // 当队列不为空时
        TreeNode* node = Dequeue(q); // 从队列中取出一个节点
        printf("%d ", node->val); // 打印节点值
        if (node->left) Enqueue(q, node->left); // 如果左子节点存在，加入队列
        if (node->right) Enqueue(q, node->right); // 如果右子节点存在，加入队列
    }
    printf("\n");
    FreeQueue(q); // 释放队列内存
}

// 释放队列内存
void FreeQueue(Queue* q) {
    free(q->elements); // 释放队列元素数组内存
    free(q); // 释放队列结构体内存
}

```
```
