---
{"dg-publish":true,"permalink":"/obsidian///fds//hw/","created":"2024-04-10T00:02:19.258+08:00","updated":"2024-09-08T15:25:05.374+08:00"}
---

33333333333333333# HW1
# è®¡ç®—æ—¶é—´å¤æ‚åº¦
1. æ ¹æ®é€’å½’![Pasted image 20240423184255.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240423184255.png)
2. 
# HW4
## èŠ‚ç‚¹æ•°ä¸å­©å­æ ‘
![Pasted image 20240410010528.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240410010528.png)
1. æ€è·¯
	
# HW5
## BSTèŠ‚ç‚¹çš„åˆ é™¤
1. æ€è·¯ï¼šå·¦å­æ ‘æ‰¾æœ€å¤§/å³å­æ ‘æ‰¾æœ€å°æ¥ä»£æ›¿
2. ä¾‹é¢˜ï¼š![Pasted image 20240410004237.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240410004237.png)
3. å¦‚æœæ˜¯å°†æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹å»ä»£æ›¿æ ¹èŠ‚ç‚¹ï¼Œè¿™ä¸ªå¶å­ç›´æ¥è·Ÿåœ¨åŸèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
## å†³ç­–æ ‘
1. é¢˜ç›®![Pasted image 20240410004741.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240410004741.png)
	1. ANSï¼šA
	2. è§£è¯»ï¼šæ ‘çš„å½¢çŠ¶éœ€è¦<mark style="background: #FFF3A3A6;">ä¿æŒ</mark>å·¦å­æ ‘èŠ‚ç‚¹ä¸€ç›´<mark style="background: #FFF3A3A6;">>=</mark>å³å­æ ‘ï¼ˆæˆ–è€…ç›¸åï¼‰
# HW6
## çº¿æ€§æ—¶é—´æ„é€ MinHeap
1. æ€è·¯
>ä»$n$/2-1çš„èŠ‚ç‚¹ç´¢å¼•å¼€å§‹ï¼Œé€’å½’åœ°é€’å‡ä¸Šæµ®èŠ‚ç‚¹(root:1)
2. é¢˜ç›®ï¼š![Pasted image 20240410001037.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240410001037.png)
3. è§£ç­”
	1. ä»£ç [[obsidian/ä¸ªäººçŸ¥è¯†åº“/å¤§ä¸€/FDS/æ•°æ®ç»“æ„/4.å †çš„è¯¾å ‚ç¬”è®°#â‘¤çº¿æ€§æ—¶é—´æ„é€ MinHeap\|4.å †çš„è¯¾å ‚ç¬”è®°#â‘¤çº¿æ€§æ—¶é—´æ„é€ MinHeap]]
	2. è‡ªç„¶è¯­è¨€
		1. çº¿æ€§æ„å»ºï¼š
			1. ä»éå¶èŠ‚ç‚¹å¼€å§‹ï¼Œåªå…³æ³¨å½“å‰èŠ‚ç‚¹æ˜¯å¦æ¯”å­èŠ‚ç‚¹å¤§
			2. å¦‚æœå­èŠ‚ç‚¹æ›´å°åˆ™äº¤æ¢ï¼Œå¹¶ä¸”é€’å½’è°ƒç”¨å­èŠ‚ç‚¹ï¼ˆä¸‹æ²‰åˆ°åº•ï¼‰
			3. ç›´è‡³æ ¹èŠ‚ç‚¹è¢«è°ƒç”¨
		2. æ’å…¥å…ƒç´ ï¼š
			1. ä»å°¾éƒ¨åˆå§‹åŒ–
			2. ä¸æ ¹èŠ‚ç‚¹æ¯”è¾ƒï¼Œå†³å®šæ˜¯å¦ä¸Šæµ®
			3. ä¾æ¬¡é€’å½’
		>æ³¨æ„è¿™ä¸¤è€…ä¸åŒ

## d-å †çš„ç´¢å¼•
### é¢˜ç›®ï¼š
![Pasted image 20240410003035.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240410003035.png)
## å‰åºä¸ä¸­åºæ„å»ºå”¯ä¸€äºŒå‰æ ‘
### åŸç†
1. å‰åºï¼šæ ¹å·¦å³
2. ä¸­åºï¼šå·¦æ ¹å³
3. æ‰€ä»¥å…ˆä»å‰åºçš„ç¬¬ä¸€ä¸ªæ‰¾åˆ°æ ¹ï¼Œä»ä¸­åºå°†æ ‘åˆ†ä¸ºå·¦å³å­æ ‘
4. é€’å½’å®Œæˆä¸Šè¿°
## å‡½æ•°ï¼šä¸Šæµ®ä¸ä¸‹æ²‰
```c
void PercolateUp( int p, PriorityQueue H )
{
    if(p<1 || p > H->Size){
        //printf("Invalid input!n");
        return;
    }
    for(int i=p;i>0;){
        int parent = i/2;
        if(H->Elements[parent] > H->Elements[i]){
            int tmp = H->Elements[parent] ;
            H->Elements[parent] = H->Elements[i];
            H->Elements[i] = tmp;
            i = parent;
        }
        else
            break;
    }
    return;
}

void PercolateDown( int p, PriorityQueue H )
{
    if(p < 1 || p>H->Size){
        //printf("Invalid input!\n");
        return;
    }
    int child;
    for(child = 2*p;child <= H->Size;child = 2*p){
        if(child+1 < H->Size && H->Elements[child+1] < H->Elements[child])
            child+=1;
        if(H->Elements[p] > H->Elements[child]){
            int tmp = H->Elements[p];
            H->Elements[p] = H->Elements[child];
            H->Elements[child] = tmp;
            p = child;
        }
        else
            break;
    }
    return;
}
```
## ç¼–ç¨‹ï¼šCBT+BSTçš„å±‚åºè¾“å‡º
```c
#include <stdio.h>
#include <stdlib.h>

// å®šä¹‰äºŒå‰æ ‘èŠ‚ç‚¹çš„ç»“æ„ä½“
typedef struct TreeNode {
    int val; // èŠ‚ç‚¹å€¼
    struct TreeNode* left; // å·¦å­èŠ‚ç‚¹æŒ‡é’ˆ
    struct TreeNode* right; // å³å­èŠ‚ç‚¹æŒ‡é’ˆ
} TreeNode;

// å®šä¹‰é˜Ÿåˆ—ç»“æ„ä½“ï¼Œç”¨äºå±‚åºéå†
typedef struct {
    TreeNode** elements; // å­˜å‚¨é˜Ÿåˆ—å…ƒç´ çš„æ•°ç»„
    int front; // é˜Ÿåˆ—çš„å¤´æŒ‡é’ˆ
    int rear; // é˜Ÿåˆ—çš„å°¾æŒ‡é’ˆ
    int size; // é˜Ÿåˆ—å½“å‰çš„å…ƒç´ æ•°é‡
    int capacity; // é˜Ÿåˆ—çš„æœ€å¤§å®¹é‡
} Queue;

// å‡½æ•°åŸå‹å£°æ˜
TreeNode* CreatNode(int val);
void BubbleSort(int* arr, int n);
TreeNode** BuildCBT(int* arr, int n);
void InorderFillValues(TreeNode* node, int* arr, int* index);
void LevelOrderTraversal(TreeNode* root, int n);
Queue* CreatQueue(int capacity);
void Enqueue(Queue* q, TreeNode* node);
TreeNode* Dequeue(Queue* q);
void FreeQueue(Queue* q);

int main() {
    int n; // å­˜å‚¨ç”¨æˆ·è¾“å…¥çš„èŠ‚ç‚¹æ•°
    scanf("%d", &n);
    int* arr = (int*)malloc(n * sizeof(int)); // åŠ¨æ€åˆ†é…æ•°ç»„å­˜å‚¨èŠ‚ç‚¹å€¼
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]); // è¯»å–èŠ‚ç‚¹å€¼
    }

    BubbleSort(arr, n); // å¯¹èŠ‚ç‚¹å€¼è¿›è¡Œå†’æ³¡æ’åº

    TreeNode** nodes = BuildCBT(arr, n); // æ„å»ºå®Œå…¨äºŒå‰æ ‘æ¡†æ¶
    int index = 0;
    InorderFillValues(nodes[0], arr, &index); // ä¸­åºéå†å¡«å……æ ‘çš„å€¼

    LevelOrderTraversal(nodes[0], n); // æ‰§è¡Œå±‚åºéå†å¹¶æ‰“å°ç»“æœ

    // é‡Šæ”¾å†…å­˜èµ„æº
    free(arr);
    free(nodes);
    return 0;
}

// åˆ›å»ºä¸€ä¸ªæ–°çš„TreeNodeèŠ‚ç‚¹
TreeNode* CreatNode(int val) {
    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode)); // åˆ†é…å†…å­˜
    node->val = val; // è®¾ç½®èŠ‚ç‚¹å€¼
    node->left = NULL; // åˆå§‹åŒ–å·¦å­èŠ‚ç‚¹ä¸ºç©º
    node->right = NULL; // åˆå§‹åŒ–å³å­èŠ‚ç‚¹ä¸ºç©º
    return node;
}

// ä½¿ç”¨å†’æ³¡æ’åºç®—æ³•å¯¹æ•°ç»„è¿›è¡Œæ’åº
void BubbleSort(int* arr, int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp; // äº¤æ¢å…ƒç´ 
            }
        }
    }
}

// æ„å»ºå®Œå…¨äºŒå‰æ ‘çš„æ¡†æ¶ï¼Œä¸è€ƒè™‘èŠ‚ç‚¹å…·ä½“å€¼
TreeNode** BuildCBT(int* arr, int n) {
    TreeNode** nodes = (TreeNode**)malloc(n * sizeof(TreeNode*)); // åˆ†é…èŠ‚ç‚¹æŒ‡é’ˆæ•°ç»„
    for (int i = 0; i < n; i++) {
        nodes[i] = CreatNode(0); // åˆ›å»ºèŠ‚ç‚¹ï¼Œåˆå§‹å€¼ä¸º0
    }
    for (int i = 0; i < n; i++) {
        if (2 * i + 1 < n) nodes[i]->left = nodes[2 * i + 1]; // è®¾ç½®å·¦å­èŠ‚ç‚¹
        if (2 * i + 2 < n) nodes[i]->right = nodes[2 * i + 2]; // è®¾ç½®å³å­èŠ‚ç‚¹
    }
    return nodes;
}

// é€šè¿‡ä¸­åºéå†çš„æ–¹å¼å¡«å……æ ‘çš„å€¼
void InorderFillValues(TreeNode* node, int* arr, int* index) {
    if (node == NULL) return; // å¦‚æœèŠ‚ç‚¹ä¸ºç©ºï¼Œåˆ™è¿”å›
    InorderFillValues(node->left, arr, index); // é€’å½’å¡«å……å·¦å­æ ‘
    node->val = arr[(*index)++]; // è®¾ç½®èŠ‚ç‚¹å€¼ï¼Œå¹¶ç§»åŠ¨æ•°ç»„ç´¢å¼•
    InorderFillValues(node->right, arr, index); // é€’å½’å¡«å……å³å­æ ‘
}

// åˆ›å»ºä¸€ä¸ªé˜Ÿåˆ—ï¼Œç”¨äºå±‚åºéå†
Queue* CreatQueue(int capacity) {
    Queue* q = (Queue*)malloc(sizeof(Queue)); // åˆ†é…é˜Ÿåˆ—ç»“æ„ä½“å†…å­˜
    q->elements = (TreeNode**)malloc(capacity * sizeof(TreeNode*)); // åˆ†é…é˜Ÿåˆ—å…ƒç´ æ•°ç»„å†…å­˜
    q->front = 0;
    q->rear = 0;
    q->size = 0;
    q->capacity = capacity;
    return q;
}

// å‘é˜Ÿåˆ—ä¸­æ·»åŠ ä¸€ä¸ªå…ƒç´ 
void Enqueue(Queue* q, TreeNode* node) {
    if (q->size == q->capacity) return; // å¦‚æœé˜Ÿåˆ—å·²æ»¡ï¼Œåˆ™ä¸æ·»åŠ 
    q->elements[q->rear] = node; // å°†èŠ‚ç‚¹æ·»åŠ åˆ°é˜Ÿå°¾
    q->rear = (q->rear + 1) % q->capacity; // å¾ªç¯é˜Ÿåˆ—æ›´æ–°é˜Ÿå°¾ä½ç½®
    q->size++; // é˜Ÿåˆ—å¤§å°å¢åŠ 
}

// ä»é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªå…ƒç´ 
TreeNode* Dequeue(Queue* q) {
    if (q->size == 0) return NULL; // å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œåˆ™è¿”å›NULL
    TreeNode* node = q->elements[q->front]; // å–å‡ºé˜Ÿå¤´å…ƒç´ 
    q->front = (q->front + 1) % q->capacity; // å¾ªç¯é˜Ÿåˆ—æ›´æ–°é˜Ÿå¤´ä½ç½®
    q->size--; // é˜Ÿåˆ—å¤§å°å‡å°‘
    return node;
}

// å±‚åºéå†äºŒå‰æ ‘å¹¶æ‰“å°èŠ‚ç‚¹å€¼
void LevelOrderTraversal(TreeNode* root, int n) {
    int flag = 1;
    Queue* q = CreatQueue(n); // åˆ›å»ºè¶³å¤Ÿå¤§çš„é˜Ÿåˆ—
    Enqueue(q, root); // å°†æ ¹èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
    while (q->size > 0) { // å½“é˜Ÿåˆ—ä¸ä¸ºç©ºæ—¶
        TreeNode* node = Dequeue(q); // ä»é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªèŠ‚ç‚¹
        if(flag){
            printf("%d", node->val); // ç¬¬ä¸€æ¬¡æ‰“å°èŠ‚ç‚¹å€¼
            flag = 0;
        }else{
             printf(" %d", node->val); // åç»­æ‰“å°æ‰“å°èŠ‚ç‚¹å€¼
        }
        if (node->left) Enqueue(q, node->left); // å¦‚æœå·¦å­èŠ‚ç‚¹å­˜åœ¨ï¼ŒåŠ å…¥é˜Ÿåˆ—
        if (node->right) Enqueue(q, node->right); // å¦‚æœå³å­èŠ‚ç‚¹å­˜åœ¨ï¼ŒåŠ å…¥é˜Ÿåˆ—
    }
    printf("\n");
    FreeQueue(q); // é‡Šæ”¾é˜Ÿåˆ—å†…å­˜
}

// é‡Šæ”¾é˜Ÿåˆ—å†…å­˜
void FreeQueue(Queue* q) {
    free(q->elements); // é‡Šæ”¾é˜Ÿåˆ—å…ƒç´ æ•°ç»„å†…å­˜
    free(q); // é‡Šæ”¾é˜Ÿåˆ—ç»“æ„ä½“å†…å­˜
}

```
# HW7
## ç¼–ç¨‹
1. è¦æ±‚
	1. ç¬¬ä¸€è¡Œç»™å‡ºnè¡¨ç¤ºå­˜åœ¨nä¸ªèŠ‚ç‚¹
	2. ä¹‹åæ¯è¡Œç»™å‡ºçš„æ ¼å¼ä¸¾ä¾‹å¦‚ä¸‹
		1. I 2 5   è¡¨ç¤º2,5å¹¶
		2. C 1 4   è¡¨ç¤ºæ£€æŸ¥1 4æ˜¯å¦åœ¨åŒä¸€ä¸ªé›†åˆ
	3. é¢å¤–çš„è¾“å‡ºï¼š
		1. æ£€æŸ¥æœ€åæœ‰å‡ ä¸ªç‹¬ç«‹çš„é›†åˆ
2. code:
```c
#include<stdio.h>
#include<stdlib.h>
int Find(int* arr,int x);
void UnionBySize(int x,int y,int* arr);

int main()
{
    int n,x,y,countSet=0;
    char operator;
    scanf("%d",&n);
    int* parent=(int*)malloc(sizeof(int)*n);
    for(int i=0;i<n;i++){
        parent[i] = -1;
    }
    scanf(" %c",&operator);
    while(operator != 'S'){
        scanf("%d %d",&x,&y);
        switch(operator){
            case 'I':
                if(Find(parent,x) != Find(parent,y))
                UnionBySize(x,y,parent);
                break;
            case 'C':
                if(Find(parent,x) == Find(parent,y)){
                    printf("yes\n");
                }else
                    printf("no\n");
                break;
                }
        scanf(" %c",&operator);
    }
    for(int i=0;i<n;i++){
        if(parent[i] < 0)
            countSet+=1;}
    if(countSet == 1){
        printf("The network is connected.\n");
    }else{
        printf("There are %d components.\n",countSet);
    }
}

int Find(int* arr,int x)
{
    if(arr[x]<0)
        return x;
    else
        return arr[x] = Find(arr,arr[x]);
}

void UnionBySize(int x,int y,int* arr)
{
    int root_x = Find(arr,x);
    int root_y = Find(arr,y);
    if(root_x != root_y){
        //å¦‚æœxæ‰€åœ¨æ ‘çš„èŠ‚ç‚¹æ•°æ›´å¤šï¼Œå°†yæ’å…¥x
        if(arr[root_x] < arr[root_y]){
            arr[root_x]+=arr[root_y];//æ›´æ–°xæ‰€åœ¨æ ‘çš„èŠ‚ç‚¹æ•°
            arr[root_y] = root_x;
        }else{
            arr[root_y]+=arr[root_x];//æ›´æ–°yæ‰€åœ¨æ ‘çš„èŠ‚ç‚¹æ•°
            arr[root_x] = root_y;
        }
    }
}
```
# HW8
## éè¿é€šGçš„E->V
1. é¢˜ç›®ï¼š![Pasted image 20240419194641.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240419194641.png)
2. ç­”æ¡ˆï¼š`10`
3. åˆ†æï¼š
	1. 8ä¸ªé¡¶ç‚¹æœ€å¤šæœ‰7x8/2=28æ¡è¾¹ï¼Œ9ä¸ªé¡¶ç‚¹æœ€å¤šæœ‰8x9/2=36æ¡è¾¹
	2. å–9ä¸ªé¡¶ç‚¹ï¼Œä½†æ˜¯ç”¨åˆ°35æ¡è¾¹ï¼Œç„¶åå†ä»¤å–ä¸€ä¸ªå­¤ç«‹çš„é¡¶ç‚¹
	3. è¿™æ ·å°±æ»¡è¶³ä¸€å…±æœ‰35æ¡è¾¹ï¼Œä¸”ä¸è¿é€š
## æ¨¡æ‹Ÿæ‹“æ‰‘ç®—æ³•
1. é¢˜ç›®![Pasted image 20240419201440.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240419201440.png)
2. å…³é”®ï¼šç‰¹åˆ«æ³¨æ„ï¼Œåªæœ‰<mark style="background: #FFF3A3A6;">å…¥åº¦ä¸º0æ—¶æ‰ä¼šå…¥é˜Ÿï¼</mark>
## (å‡½æ•°)æ ¹æ®ç»™å®šçš„å›¾åˆ¤æ–­æ‹“æ‰‘æ’åºæ˜¯å¦åˆç†
1. æ€è·¯ï¼š
	æˆ‘ä»¬å¯ä»¥**ç›´æ¥**å¯¹å›¾è¿›è¡Œæ‹“æ‰‘æ’åºï¼Œåˆ©ç”¨å›æº¯ç­‰æ‰‹æ®µå¾—åˆ°æ‰€æœ‰å¯èƒ½çš„æ‹“æ‰‘æ’åºçš„ç»“æœï¼›
	ç„¶è€Œï¼Œå­˜åœ¨ä¸€ç§<mark style="background: #FFF3A3A6;">æ›´åŠ é«˜æ•ˆ</mark>çš„æ–¹å¼â€”â€”æ ¹æ®å›¾æ„å»ºä¸€ä¸ªå­˜å‚¨å…¥åº¦çš„æ•°ç»„ï¼ˆå¦‚æœè¿˜ä¸å­˜åœ¨çš„è¯ï¼‰ï¼Œç„¶åéå†æ’åºçš„ç»“æœï¼Œæ¯æ¬¡éƒ½æ£€æŸ¥é¡¶ç‚¹çš„å…¥åº¦æ˜¯å¦ä¸º0ï¼šå¦‚æœæ˜¯ï¼Œåˆ™å°†è¿™ä¸ªé¡¶ç‚¹æ‰€æŒ‡å‘çš„é¡¶ç‚¹çš„å…¥åº¦--ï¼›å¦åˆ™ï¼Œè¿”å›false.
2. ç®€åŒ–æ€è·¯çš„ä»£ç å®ç°ï¼š
```c
bool IsTopSeq(LGraph Graph, Vertex Seq[]) {
    // åˆå§‹åŒ–å…¥åº¦æ•°ç»„ï¼Œæ•°ç»„å¤§å°ä¸º MaxVertexNum + 1 ä»¥ç›´æ¥ä½¿ç”¨é¡¶ç‚¹ç¼–å·
    int inDegrees[MaxVertexNum + 1] = {0}; 

    // è®¡ç®—æ‰€æœ‰é¡¶ç‚¹çš„å…¥åº¦
    for (Vertex v = 0; v < Graph->Nv; v++) {
        PtrToAdjVNode currentNode = Graph->G[v].FirstEdge;
        // éå†é¡¶ç‚¹vçš„é‚»æ¥è¡¨ï¼Œæ›´æ–°æ‰€æœ‰é‚»æ¥é¡¶ç‚¹çš„å…¥åº¦
        while (currentNode != NULL) {
            inDegrees[currentNode->AdjV + 1]++; // è°ƒæ•´é¡¶ç‚¹ç´¢å¼•ä»¥é€‚é…ä»1å¼€å§‹çš„ç¼–å·
            currentNode = currentNode->Next;
        }
    }
    
    // æ£€æŸ¥åºåˆ—æ˜¯å¦ä¸ºæœ‰æ•ˆçš„æ‹“æ‰‘æ’åº
    for (int i = 0; i < Graph->Nv; i++) {
        Vertex currentVertex = Seq[i];
        if (inDegrees[currentVertex] != 0) {
            // å¦‚æœå½“å‰é¡¶ç‚¹çš„å…¥åº¦ä¸ä¸º0ï¼Œåˆ™åºåˆ—ä¸æ˜¯æœ‰æ•ˆçš„æ‹“æ‰‘æ’åº
            return false;
        }

        // å‡å°‘å½“å‰é¡¶ç‚¹æŒ‡å‘çš„æ‰€æœ‰é¡¶ç‚¹çš„å…¥åº¦
        PtrToAdjVNode currentNode = Graph->G[currentVertex - 1].FirstEdge;
        while (currentNode != NULL) {
            inDegrees[currentNode->AdjV + 1]--;
            currentNode = currentNode->Next;
        }
    }
    return true;
}

```
## (ç¼–ç¨‹)æ£€æŸ¥å“ˆå¯†é¡¿å›è·¯
1. é—®é¢˜åˆ†è§£
	1. ç”±ç»™å‡ºçš„ä¿¡æ¯æ„å»ºå›¾ç»“æ„
		1. æ— å‘å›¾
	2. ç”±ç»™å‡ºçš„æ•°æ®åˆ¤æ–­æ˜¯å¦å½¢æˆäº†åœˆ
		1. æ£€æŸ¥è¾“å…¥ï¼š
			1. ç»è¿‡å…¶ä»–æ‰€æœ‰é¡¶ç‚¹ä¸”åªç»è¿‡ä¸€æ¬¡ï¼›
			2. èµ·å§‹ç‚¹ç›¸åŒ
		2. æ£€æŸ¥ä¸‹ä¸€ä¸ªé¡¶ç‚¹æ˜¯å¦åœ¨ä¸Šä¸€ä¸ªé¡¶ç‚¹çš„é“¾è¡¨å…ƒç´ é‡Œ
2. ä»£ç å±•ç¤º
```c
#include<stdio.h>
#include<stdlib.h>

# define maxSize 200

typedef struct graphNode{
    int position;
    struct graphNode* next;
}graphNode;

typedef struct Graph{
    int numVertex;
    graphNode* adjList[maxSize];
}Graph;

void InitializeGraph(Graph* G,int size);//æ ¹æ®é¡¶ç‚¹æ•°åˆå§‹åŒ–å›¾
void addEdges(Graph* G,int vertex1,int vertex2);//æ„å»ºæ— å‘å›¾
int checkOnce(int* arr,int size);//åˆ¤æ–­é™¤äº†æœ€åä¸€ä¸ªå…ƒç´ ï¼Œæ‰€æœ‰å…ƒç´ æ˜¯å¦ä»…å‡ºç°äº†ä¸€æ¬¡
void checkHamiltonCycle(Graph* G,int* tmpArray,int size);//åˆ¤æ–­æ•°ç»„ä¸­çš„å…ƒç´ æ˜¯å¦æ»¡è¶³å“ˆå¯†é¡¿å›è·¯
int hasEdge(Graph* G,int former,int latter);//åˆ¤æ–­é¡¶ç‚¹ä¹‹é—´æ˜¯å¦æœ‰è¾¹

int main()
{
    int vertexSize,edge,vertex1,vertex2;
    scanf("%d %d",&vertexSize,&edge);
    Graph G;
    InitializeGraph(&G,vertexSize);
    
    //æ ¹æ®ç»™å‡ºçš„è¾¹æ•°edgeè¯»å–ä¿¡æ¯æ„å»ºadjList
    for(int i=0 ;i<edge; i++){
        scanf("%d %d",&vertex1,&vertex2);
        addEdges(&G,vertex1-1,vertex2-1);
    }
    
    int testVertex,numOfInput;
    scanf("%d",&numOfInput);
    for(int i=0; i<numOfInput; i++){
        scanf("%d",&testVertex);
        int* tmpArray = (int*)malloc(sizeof(int)*testVertex);
        for(int j=0; j<testVertex; j++){
            scanf("%d",&tmpArray[j]);
            tmpArray[j]--;
        }
        if(testVertex != vertexSize+1 || tmpArray[0] != tmpArray[vertexSize] || !checkOnce(tmpArray,testVertex)){
            printf("NO\n");
            continue;
        }
        checkHamiltonCycle(&G,tmpArray,testVertex);
    }
}



void InitializeGraph(Graph* G,int size){
    G->numVertex = size;
    for(int i=0; i<size; i++)
        G->adjList[i] = NULL;
}

void addEdges(Graph* G,int vertex1,int vertex2){
    graphNode* newNode = (graphNode*)malloc(sizeof(graphNode));
    newNode->position = vertex2;
    newNode->next = G->adjList[vertex1];
    G->adjList[vertex1] = newNode;
    
    //ä¸ºæ— å‘å›¾ï¼Œå› æ­¤ä¸ºåŒæ–¹éƒ½åŠ è¾¹
    newNode = (graphNode*)malloc(sizeof(graphNode));
    newNode->position = vertex1;
    newNode->next = G->adjList[vertex2];
    G->adjList[vertex2] = newNode;
}
//é€šè¿‡å¯¹å‰ä¸€ä¸ªé¡¶ç‚¹çš„é“¾è¡¨è¿›è¡Œéå†ï¼Œç›´è‡³æ‰¾åˆ°åä¸€ä¸ªé¡¶ç‚¹æˆ–è€…ä¸ºNULL
void checkHamiltonCycle(Graph* G,int* tmpArray,int size){
    int former,latter;
    for(int i=0; i<size-1; i++){
        former = tmpArray[i];
        latter = tmpArray[i+1];
        if(hasEdge(G,former,latter) == 0){
            printf("NO\n");
            return;
        }
    }
    printf("YES\n");
    return;
}

int hasEdge(Graph* G,int former,int latter){
    graphNode* tmp = G->adjList[former];
    while(tmp!=NULL){
        if(tmp->position == latter)
            return 1;
        tmp = tmp->next;
    }
    return 0;
}

int checkOnce(int* arr,int size){
    int count[maxSize]={0};
    for(int i=1; i<size; i++){
        count[arr[i]] = 1;
    }
    for(int i=0; i<size-1; i++){
        if(count[i] == 0)
            return 0;
    }
    return 1;
}

```
# HW9
## æœ€çŸ­è·¯å¾„å› æƒå€¼å˜åŒ–çš„å½±å“
- åŸæœ¬çš„æœ€çŸ­è·¯å¾„Pï¼Œåœ¨`æ‰€æœ‰edgeçš„æƒå€¼å‡+2`ä¹‹åä¸ä¸€å®šä¾æ—§ä¸ºæœ€çŸ­è·¯å¾„
- è§£é‡Šï¼šè€ƒè™‘Pç»å†çš„è¾¹æ•°è¾ƒå¤šçš„æƒ…å†µã€‚æ­¤æ—¶å¯¹Pçš„å½±å“è¾ƒå¤§
## æ‰¾åˆ°Dijkstraç®—æ³•çš„æ ‡è®°è·¯å¾„
- å«ä¹‰ï¼šæ¨¡æ‹Ÿç®—æ³•çš„è´ªå¿ƒæ€§è´¨ï¼ˆæ¯æ¬¡é€‰æ‹©Disæœ€å°çš„ç‚¹ï¼‰ï¼Œè¿›è¡Œæ ‡è®°
- é¢˜ç›®ï¼š[[obsidian/ä¸ªäººçŸ¥è¯†åº“/å¤§ä¸€/FDS/æ•°æ®ç»“æ„/7.å›¾è®º#Dijkstra ç®—æ³•\|7.å›¾è®º#Dijkstra ç®—æ³•#æ¨¡æ‹Ÿå®ç°ï¼š]]
	âœ…2-4-3-6-5-7
# HW10

## å«æ˜Ÿç«™
```c
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<limits.h>

#define numV 500


typedef struct edgeNode {
	int adjVertex;
	int weight;
	struct edgeNode* next;
}edgeNode;



typedef struct {
	int vertex;
	edgeNode* firstEdge;
}vertexNode;

typedef struct {
	int numVertex;
	int numEdge;
	vertexNode* adjList;
}Graph;


//function
int maxFlowCheck(Graph* G, int src, int dst);
int BFS(Graph* G, int src, int dst, int* path);
void updateGraph(Graph* G, int* path, int src);
int findMinFlow(Graph* G, int* path, int src);
int FindWeight(int start, int end, Graph* G);
void updateEdge(int start, int end, Graph* G, int minFlow);
int checkId(char arr[numV][4], char* str, int* count);//é¢˜ç›®è¯´æœ€å¤šæœ‰500æ¡è¾¹ï¼Œå› æ­¤æœ€å¤šæœ‰1000ä¸ªé¡¶ç‚¹


Graph* initialGraph(int numVertex) {
	Graph* G = (Graph*)malloc(sizeof(Graph));
	G->numVertex = numVertex;
	G->adjList = (vertexNode*)malloc(sizeof(vertexNode) * (numVertex + 1));
	for (int i = 0; i < numVertex; i++)
		G->adjList[i].firstEdge = NULL;
	return G;
}


int maxFlowCheck(Graph* G, int src, int dst) {
	
	//printf("Checking flow from %d to %d\n", src, dst);
	
	//å­˜å‚¨æ˜¯å¦éå†è¿‡çš„knownæ•°ç»„ä»¥åŠè·¯å¾„path
	//è¿™æ˜¯å› ä¸ºåœ¨æ¯æ¬¡æ›´æ–°è¾¹çš„å…³ç³»ä¹‹åï¼Œknownä»¥åŠpathéœ€è¦é‡ç½®ï¼Œå› æ­¤ä¸å¯ä»¥ä¸å›¾ä¸­çš„vertexç»‘å®š

	int maxFlow = 0;
	int path[numV];//ä¸ºäº†èƒ½å¤Ÿè®©è°ƒç”¨çš„BFSè¿”å›,åœ¨BFSå¤–éƒ¨åˆ›å»ºæŒ‡é’ˆï¼Œå¹¶ç”¨æŒ‡é’ˆä½œä¸ºå‚æ•°
	for (int i = 0; i < numV; i++)
		path[i] = -1;

	while (BFS(G, src, dst, path)) {
		//æ³¨æ„pathçš„åˆå§‹åŒ–ä¸æ›´æ–°
		//æ›´æ–°æµé‡å›¾G
		// æ‰¾åˆ°ä» dst åˆ° src çš„æœ€å°å®¹é‡è¾¹
		int minFlow = findMinFlow(G, path, dst);  // ä» dst å¼€å§‹å›æº¯åˆ° src
		if (minFlow == 0) break;  // å¦‚æœæ²¡æœ‰è·¯å¾„æˆ–è€…æœ€å°æµä¸º 0ï¼Œåˆ™ç»ˆæ­¢å¾ªç¯
		// æ›´æ–°ç½‘ç»œä¸­çš„æµé‡
		updateGraph(G, path, dst);
		maxFlow += minFlow;
		for (int i = 0; i < numV; i++)
			path[i] = -1;  // é‡ç½® path æ•°ç»„ä¸º -1
	}
	return maxFlow;
}

int BFS(Graph* G, int src, int dst, int* path) {
	int queue[numV];
	int visited[numV] = { 0 }; // è®¿é—®æ•°ç»„åˆå§‹åŒ–ä¸ºæœªè®¿é—®
	int front = 0, rear = 0; // é˜Ÿåˆ—çš„å¤´å’Œå°¾æŒ‡é’ˆ

	queue[rear++] = src; // å°†æºç‚¹å…¥é˜Ÿ
	visited[src] = 1; // æ ‡è®°æºç‚¹ä¸ºå·²è®¿é—®
	path[src] = -1; // æºç‚¹æ²¡æœ‰çˆ¶èŠ‚ç‚¹

	while (front != rear) {
		int current = queue[front++]; // å‡ºé˜Ÿä¸€ä¸ªå…ƒç´ 
		if (current == dst)
			return 1; // å¦‚æœå½“å‰èŠ‚ç‚¹æ˜¯ç›®æ ‡èŠ‚ç‚¹ï¼Œè¿”å›æˆåŠŸ
		edgeNode* tmp = G->adjList[current].firstEdge; // è·å–å½“å‰èŠ‚ç‚¹çš„è¾¹åˆ—è¡¨
		while (tmp != NULL) {
			int adjver = tmp->adjVertex; // è·å–é‚»æ¥é¡¶ç‚¹
			// å¦‚æœé‚»æ¥é¡¶ç‚¹æœªè¢«è®¿é—®
			if (!visited[adjver] && tmp->weight > 0) {
				visited[adjver] = 1; // æ ‡è®°ä¸ºå·²è®¿é—®
				path[adjver] = current; // è®°å½•é‚»æ¥é¡¶ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¸ºå½“å‰èŠ‚ç‚¹
				queue[rear++] = adjver; // å°†é‚»æ¥é¡¶ç‚¹å…¥é˜Ÿ
			}
			tmp = tmp->next; // è®¿é—®ä¸‹ä¸€æ¡è¾¹
		}
	}
	return 0; // å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œè¯´æ˜æ²¡æœ‰æ‰¾åˆ°è·¯å¾„ï¼Œè¿”å›å¤±è´¥
}



void updateGraph(Graph* G, int* path, int dst) {
	int minFlow = findMinFlow(G, path, dst);
	for (int v = dst; path[v]!= -1; v = path[v]) {
		int u = path[v];
		updateEdge(u,v, G, minFlow);
	}
}

//æ‰¾åˆ°å¢å¹¿è·¯å¾„ä¸­çš„æœ€å°æµé‡
//æ³¨æ„ï¼Œåº”å½“ä»dstå‡ºå‘
int findMinFlow(Graph* G, int* path, int dst) {
	if (path[dst] == -1) {
		return 0;  // å¦‚æœç›®æ ‡èŠ‚ç‚¹æ²¡æœ‰å‰é©±ï¼Œè¯´æ˜æ²¡æœ‰æ‰¾åˆ°è·¯å¾„
	}
	int minFlow = INT_MAX; // è®¾ç½®ä¸€ä¸ªéå¸¸å¤§çš„åˆå§‹å€¼
	for (int v = dst; path[v] != -1; v = path[v]) {
		int u = path[v];
		int currentFlow = FindWeight(u, v, G);
		if (currentFlow < minFlow) {
			minFlow = currentFlow; // æ›´æ–°æœ€å°æµé‡
		}
	}
	return minFlow;
}


//ç”±ç»™å‡ºçš„é¡¶ç‚¹è·å¾—ä¹‹é—´çš„è¾¹çš„æƒå€¼
int FindWeight(int start, int end, Graph* G) {
	edgeNode* tmp = G->adjList[start].firstEdge;
	while (tmp!= NULL && tmp->adjVertex != end)
		tmp = tmp->next;
	if (tmp == NULL)
		return -1;
	return tmp->weight;
}


//æ›´æ–°æµé‡å›¾ï¼ŒåŒ…æ‹¬ä¸ºæ­£å‘å‡å€¼å’Œè´Ÿå‘åŠ å€¼
void updateEdge(int start, int end, Graph* G, int minFlow) {
	edgeNode* tmp = G->adjList[start].firstEdge;
	while (tmp!= NULL && tmp->adjVertex != end)
		tmp = tmp->next;
	if (tmp  != NULL)
		tmp->weight -= minFlow;

	//æ·»åŠ åæ–¹å‘çš„è¾¹
	tmp = G->adjList[end].firstEdge;
	while (tmp != NULL && tmp->adjVertex != start)
		tmp = tmp->next;
	if (tmp == NULL) {
		edgeNode* newNode = (edgeNode*)malloc(sizeof(edgeNode));
		newNode->adjVertex = start;
		newNode->next = G->adjList[end].firstEdge;
		newNode->weight = minFlow;
		G->adjList[end].firstEdge = newNode;
	}
	else {
		tmp->weight += minFlow;
	}

}

int checkId(char arr[numV][4], char* str, int* count) {
	for (int i = 0; i < *count; i++) {
		if (strcmp(arr[i], str) == 0)
			return i;
	}
	strcpy(arr[*count], str);
	(*count)++;
	return (*count - 1);
}

//å¾—åˆ°æœ€å¤§æµ
int main() {
	int maxFlow,u,v,numEdge,weight,count;
	char* start = (char*)malloc(sizeof(char) * 4);
	char* end = (char*)malloc(sizeof(char) * 4);
	char vertexArr[numV][4];
	Graph* G = initialGraph(numV);

	scanf("%s %s %d", start, end,&numEdge);
	//æ„å»ºä»¥å­—ç¬¦ä¸²æŒ‡é’ˆä¸ºå…ƒç´ çš„æ•°ç»„ char** vertexArr,
	// æ¯æ¬¡æ£€æŸ¥startä¸endæ˜¯å¦åœ¨vertexArrå½“ä¸­ï¼Œè‹¥å¦ï¼ŒvertexArr[k++]æ ‡è®°ä¸ºå¯¹åº”çš„å­—ç¬¦ä¸²
	//æ¯æ¬¡å…ˆéå†å­—ç¬¦ä¸²æ•°ç»„ï¼ˆiè®°å½•ç´¢å¼•)ï¼Œå¦‚æœæ‰¾åˆ°å°±è¿”å›iä½œä¸ºå¯¹åº”å­—ç¬¦ä¸²åœ¨å›¾ä¸­çš„é¡¶ç‚¹ç´¢å¼•
	strcpy(vertexArr[1], start);
	strcpy(vertexArr[2], end);
	count = 3;
	for (int i = 0; i < numEdge; i++) {
		scanf("%s %s %d", start, end,&weight);
		u = checkId(vertexArr, start,&count);
		v = checkId(vertexArr,end,&count);
		edgeNode* newNode = (edgeNode*)malloc(sizeof(edgeNode));

		newNode->adjVertex = v;
		newNode->weight = weight;
		newNode->next = G->adjList[u].firstEdge;
		G->adjList[u].firstEdge = newNode;
	}
	//ç”±ç»™å‡ºçš„å›¾çš„ä¿¡æ¯æ„å»ºå›¾
	//å…ˆç»™å‡ºèµ·ç‚¹ï¼Œç»ˆç‚¹å¯¹åº”çš„å­—ç¬¦ä¸²ï¼Œä»¥åŠè¾¹æ•°numEdge
	//æ¥ç€ç»™å‡ºnumEdgeè¡Œï¼Œæ¯è¡Œéƒ½åŒ…æ‹¬èµ·å§‹ç‚¹å’Œweight
		//åˆ©ç”¨å“ˆå¸Œè¡¨å°†å­—ç¬¦ä¸²åç§°æ˜ å°„ä¸ºæ•´æ•°ç´¢å¼•
		//æ¯æ¬¡æ˜ å°„çš„å€¼++



	/*for (int i = 1; i < count; i++) {
		edgeNode* tmp = G->adjList[i].firstEdge;
		while (tmp != NULL) {
			printf("%d", tmp->adjVertex);
			tmp = tmp->next;
		}
		printf("\n");
	}
	printf("src is %s\n", vertexArr[1]);
	for(int i=1;i<count;i++)
	printf("%s\n", vertexArr[i]);
	*/
	maxFlow = maxFlowCheck(G, 1, 2);
	//æœ€å¤§æµç®—æ³•
		//åˆ©ç”¨BFSå¯»æ‰¾å¢å¹¿è·¯å¾„
		//æ›´æ–°æµé‡å›¾ä¸æœ€å¤§æµé‡ä¿¡æ¯
		//è¿”å›æœ€å¤§æµ	
	if (maxFlow == 0)
		return 0;
	printf("%d\n", maxFlow);
}
```
# Midterm
## è¡¥å……
1. <mark style="background: #ADCCFFA6;">ååºå…³ç³»</mark>ï¼šæ»¡è¶³è‡ªåã€<mark style="background: #FFF3A3A6;">åå¯¹ç§°</mark>ã€ä¼ é€’çš„å…³ç³»
	1. $R(x,y)ä¸R(y,x)$ä¸èƒ½åŒæ—¶æ»¡è¶³
2. åœ¨ä¸€ä¸ªæœ‰å‘å›¾ä¸­å­˜åœ¨ç¯çš„æƒ…å†µä¸‹ï¼Œä¸€å®š<mark style="background: #FFF3A3A6;">ä¸å­˜åœ¨æ‹“æ‰‘æ’åº</mark>
	- æ˜¯æœ‰å‘æ— ç¯å›¾$DAG$çš„é¡¶ç‚¹çš„çº¿æ€§æ’åºï¼Œè¦æ±‚$u\rightarrow v$çš„ä¸¥æ ¼æ–¹å‘æ€§
	- å­˜åœ¨ç¯æ—¶ï¼Œæ–¹å‘æ€§æ— æ³•å¾—ä»¥æ»¡è¶³
	- å› æ­¤ï¼Œç¯çš„å­˜åœ¨è¿èƒŒäº†æ‹“æ‰‘æ’åºçš„åŸºæœ¬è¦æ±‚
	- ï¼ˆä½†æ˜¯ï¼Œå¯ä»¥è¯´ç”¨æ‹“æ‰‘æ’åºæ¥æ£€éªŒæ˜¯å¦å­˜åœ¨ç¯ï¼Œåªæ˜¯æ— æ³•è¾“å‡ºå…¨éƒ¨é¡¶ç‚¹ï¼‰
## å¹¶æŸ¥é›†çš„è·¯å¾„å‹ç¼©
- å‘ç”Ÿæ—¶é—´ï¼šFind($x$)
- è¦ç‚¹ï¼š<mark style="background: #FFB86CA6;">å¹¶éå®Œå…¨å‹ç¼©</mark>ï¼
	- æ ¹æ®ä»£ç å¯çŸ¥[[obsidian/ä¸ªäººçŸ¥è¯†åº“/å¤§ä¸€/FDS/æ•°æ®ç»“æ„/6.å¹¶æŸ¥é›† The Disjoint Set\|6.å¹¶æŸ¥é›† The Disjoint Set]]
	- æ˜¯ä»xå¼€å§‹å¯»æ‰¾è¯¥é›†åˆçš„æ ¹èŠ‚ç‚¹
	- æœ€åå°†è¯¥è¿‡ç¨‹å½“ä¸­éå†åˆ°çš„å­èŠ‚ç‚¹éƒ½æŒ‡å‘æ ¹èŠ‚ç‚¹
	- å› æ­¤ï¼Œä¸<mark style="background: #FFF3A3A6;">åŒ…æ‹¬xçš„å­èŠ‚ç‚¹ä¸åˆ«çš„æ”¯è·¯çš„èŠ‚ç‚¹</mark>
## çº¿æ€§ä¸éçº¿æ€§
- ä¸€èˆ¬å¯¹~çš„è®¨è®ºæ˜¯ä»<mark style="background: #FFF3A3A6;">é€»è¾‘ç»“æ„</mark>å±‚é¢è¿›è¡Œçš„ï¼Œè€Œéç‰©ç†å­˜å‚¨ç»“æ„
- â“![Pasted image 20240429162620.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240429162620.png)
	âœ… <mark style="background: #FF5582A6;">C</mark> ï¼š å­—ç¬¦ä¸²ä¹Ÿå…·æœ‰ä¸€ä¸€å¯¹åº”çš„çº¿æ€§å…³ç³»ï¼Œè€Œå®Œå…¨äºŒå‰æ ‘åˆ™å…·æœ‰å±‚æ¬¡æ€§ä¸åˆ†æ”¯ç»“æ„ï¼Œå› æ­¤ä¸ºnon-linear
## å®Œå…¨äºŒå‰æ ‘çš„å¶å­èŠ‚ç‚¹æ•°
- ä¸è¦å¿½ç•¥<mark style="background: #FFF3A3A6;">å€’æ•°ç¬¬äºŒå±‚</mark>çš„å¶å­ï¼
- å…¬å¼
	- æ ¹èŠ‚ç‚¹ä¸ºç¬¬0å±‚ï¼Œåˆ™**å‰hå±‚**çš„èŠ‚ç‚¹æ€»æ•°ä¸º$2^{h+1}-1$ä¸ª
	- **ç¬¬hå±‚**çš„èŠ‚ç‚¹æ•°ä¸º$2^h$ä¸ª
- â“![Pasted image 20240429163242.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240429163242.png)
	- âœ… <mark style="background: #FF5582A6;">B</mark> ï¼šå…ˆç®—å‡ºæœ‰9å±‚æ»¡ï¼Œç„¶åè®¡ç®—10å±‚çš„æ•°ç›®ï¼Œæ¥ç€è®¡ç®—ç¬¬10å±‚æ‰€å½±å“çš„çˆ¶èŠ‚ç‚¹æ•°ï¼Œå›åˆ°ç¬¬9å±‚ç®—å‡ºå‰©ä¸‹çš„å¶å­æ•°ã€‚æœ€åå°†ä¸¤éƒ¨åˆ†çš„å¶å­èŠ‚ç‚¹æ•°å¢åŠ ã€‚
- ä¸¾ä¾‹âœ…![a6a627a2a3dd9bcb6538967fd7c6a25.jpg](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/a6a627a2a3dd9bcb6538967fd7c6a25.jpg)
## ç»™å‡ºVä¸Eæ±‚æœ€å¤§è¿é€šæ•°
- è¦ç‚¹ï¼š
	- è¦å°½å¯èƒ½å¾—åˆ°å•ç‹¬çš„é¡¶ç‚¹ï¼ˆæ¯ä¸ªé¡¶ç‚¹å°±æ˜¯ä¸€ä¸ªè¿é€šåˆ†é‡ï¼‰ï¼Œæ­¤æ—¶èƒ½ç¡®ä¿å¾—åˆ°æœ€å¤§çš„è¿é€šæ•°
	- å› æ­¤ï¼Œè¦å°½å¯èƒ½å°†è¾¹å¿«é€Ÿç”¨å®Œ
	- æ˜¾ç„¶ï¼Œ1Eå¯¹2Vçš„æ•ˆç‡è¾ƒä½ï¼Œå¯ä»¥è®©Nä¸ªç‚¹ç»„æˆçš„ç³»ç»Ÿä¸­ä¸¤ä¸¤ç›¸è¿ï¼Œæ­¤æ—¶æœ€å¤šæ¶ˆè€—$\frac {N(N-1)} 2$æ¡è¾¹
	- ç„¶åå–å‰©ä¸‹çš„é¡¶ç‚¹å•ç‹¬ä½œä¸ºè¿é€šåˆ†é‡ï¼Œæœ€ååŠ 1
- â“![Pasted image 20240429164003.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240429164003.png)
	âœ… <mark style="background: #FF5582A6;">C</mark> : å…ˆå–N=7ç”¨å®Œ17æ¡è¾¹ï¼Œå‰©ä½™43ä¸ªé¡¶ç‚¹ã€‚å› æ­¤ï¼Œ43+1=44.
# HW11
## åˆ¤æ–­é¢˜ï¼š
1. â“After the first run of Insertion Sort, it is possible that no element is placed in its final position.
	1. æ„æ€æ˜¯ï¼šåœ¨ç¬¬ä¸€æ¬¡æ’å…¥æ’åºç»“æŸåï¼Œæ˜¯å¦å¯èƒ½æ²¡æœ‰ä¸€ä¸ªå…ƒç´ åœ¨æ­£ç¡®çš„ä½ç½®ä¸Š
	2. ç†è§£äº†é¢˜ç›®çš„æ„æ€ä¹‹åï¼Œä¸éš¾å‘ç°è¿™ä¸ªè¯´æ³•æ˜¯æ­£ç¡®çš„
2. â“Apply DFS to a directed acyclic graph, and output the vertex before the end of each recursion. The output sequence will be:
	1. âœ…reversely topologically sorted
	2. æ„æ€æ˜¯ï¼šåœ¨æ‰§è¡ŒDFSçš„é€’å½’è°ƒç”¨æ—¶ï¼Œé€’å½’å°†ç»“æŸæ—¶å¼€å§‹è¾“å‡ºå½“å‰çš„é¡¶ç‚¹å€¼å¹¶å›æº¯ï¼ˆè€Œéæ ‡è®°ä¹‹åç›´æ¥è¾“å‡ºï¼‰ã€‚å› æ­¤æ˜¯é€†åºçš„æ‹“æ‰‘æ’åº
## ç¼–ç¨‹ï¼šå¼ºè¿é€šåˆ†é‡
### Tarjan's
```c
void StronglyConnectedComponents(Graph G, void (*visit)(Vertex V))
{
    int count = 0, rear = 0;
    Vertex stack[MaxVertices];
    int disc[MaxVertices];
    int low[MaxVertices];
    int inStack[MaxVertices] = {0};  // è®°å½•å“ªäº›é¡¶ç‚¹åœ¨æ ˆä¸­

    // åˆå§‹åŒ– disc å’Œ low æ•°ç»„
    for (int i = 0; i < MaxVertices; i++) {
        disc[i] = -1;
        low[i] = -1;
    }

    // æ·±åº¦ä¼˜å…ˆæœç´¢å‡½æ•°
    void DFS(Vertex u) {
        // åˆå§‹åŒ–é¡¶ç‚¹ u çš„ discovery time å’Œ low å€¼
        disc[u] = low[u] = count++;
        // å°†é¡¶ç‚¹ u å…¥æ ˆï¼Œå¹¶æ ‡è®°ä¸ºåœ¨æ ˆä¸­
        stack[rear++] = u;
        inStack[u] = 1;

        // éå†é¡¶ç‚¹ u çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹ v
        PtrToVNode tmp = G->Array[u];
        while (tmp != NULL) {
            Vertex v = tmp->Vert;
            if (disc[v] == -1) {  // å¦‚æœé¡¶ç‚¹ v æœªè¢«è®¿é—®
                DFS(v);  // é€’å½’è®¿é—®é¡¶ç‚¹ v
                low[u] = (low[u] < low[v]) ? low[u] : low[v];  // æ›´æ–° low[u]
            } else if (inStack[v]) {  // å¦‚æœé¡¶ç‚¹ v åœ¨æ ˆä¸­
                low[u] = (low[u] < disc[v]) ? low[u] : disc[v];  // æ›´æ–° low[u]
            }
            tmp = tmp->Next;
        }

        // å¦‚æœé¡¶ç‚¹ u æ˜¯å¼ºè¿é€šåˆ†é‡çš„æ ¹
        if (disc[u] == low[u]) {
            Vertex w;
            // ä»æ ˆä¸­å¼¹å‡ºé¡¶ç‚¹ï¼Œç›´åˆ°é¡¶ç‚¹ u
            do {
                w = stack[--rear];
                inStack[w] = 0;
                visit(w);  // è¾“å‡ºé¡¶ç‚¹ w
            } while (w != u);
            printf("\n");
        }
    }

    // éå†æ‰€æœ‰é¡¶ç‚¹ï¼Œå¦‚æœé¡¶ç‚¹æœªè¢«è®¿é—®ï¼Œåˆ™è¿›è¡Œ DFS
    for (int i = 0; i < G->NumOfVertices; i++) {
        if (disc[i] == -1) {
            DFS(i);
        }
    }
}
```
### åˆ†æï¼š
- å¦‚æœ `disc[u] == low[u]`ï¼Œåˆ™ä»æ ˆä¸­å¼¹å‡ºé¡¶ç‚¹ï¼Œç›´åˆ°é¡¶ç‚¹ `u`ï¼Œæ„æˆä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ã€‚
#### `inStack` çš„ä½œç”¨
1. **é˜²æ­¢é‡å¤æ·»åŠ é¡¶ç‚¹åˆ°æ ˆä¸­**ï¼š
    - `inStack` æ•°ç»„è®°å½•äº†å“ªäº›é¡¶ç‚¹å·²ç»åœ¨æ ˆä¸­ã€‚å½“éå†é¡¶ç‚¹çš„é‚»æ¥é¡¶ç‚¹æ—¶ï¼Œå¦‚æœä¸€ä¸ªé‚»æ¥é¡¶ç‚¹å·²ç»åœ¨æ ˆä¸­ï¼Œé‚£ä¹ˆå®ƒçš„ `low` å€¼å’Œ `disc` å€¼å·²ç»åœ¨å½“å‰ DFS è·¯å¾„ä¸Šè¢«å¤„ç†è¿‡äº†ï¼Œä¸éœ€è¦å†æ¬¡å¤„ç†ã€‚
2. **æ­£ç¡®æ›´æ–° `low` å€¼**ï¼š
    - å½“éå†åˆ°ä¸€ä¸ªåœ¨æ ˆä¸­çš„é‚»æ¥é¡¶ç‚¹æ—¶ï¼Œè¡¨æ˜åœ¨å½“å‰ DFS è·¯å¾„ä¸Šå­˜åœ¨ä¸€ä¸ªå›è¾¹ã€‚ä¸ºäº†æ­£ç¡®æ›´æ–°å½“å‰é¡¶ç‚¹çš„ `low` å€¼ï¼Œéœ€è¦ä½¿ç”¨ `inStack` æ•°ç»„æ¥ç¡®è®¤è¿™ä¸ªé‚»æ¥é¡¶ç‚¹åœ¨æ ˆä¸­ã€‚åªæœ‰åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‰æ›´æ–° `low` å€¼ä¸ºé‚»æ¥é¡¶ç‚¹çš„ `disc` å€¼ã€‚
3. **è¯†åˆ«å¼ºè¿é€šåˆ†é‡**ï¼š
    - å½“æ£€æµ‹åˆ°ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡æ—¶ï¼Œéœ€è¦ä»æ ˆä¸­å¼¹å‡ºé¡¶ç‚¹ã€‚å¦‚æœæ²¡æœ‰ `inStack` æ•°ç»„ï¼Œåœ¨é€’å½’å’Œå›æº¯çš„è¿‡ç¨‹ä¸­å¾ˆéš¾å‡†ç¡®åœ°ç¡®å®šå“ªäº›é¡¶ç‚¹æ˜¯å±äºå½“å‰å¼ºè¿é€šåˆ†é‡çš„ä¸€éƒ¨åˆ†ã€‚
# HW12
## å‡½æ•°ï¼šéé€’å½’çš„å½’å¹¶
>å°†Nä¸ªå…ƒç´ çœ‹ä½œNä¸ªåºåˆ—ï¼ˆåˆå§‹åŒ–ï¼‰ï¼Œç„¶åæ¯æ¬¡å–ç›¸é‚»çš„ä¸¤ä¸ªåºåˆ—è¿›è¡Œå½’å¹¶ï¼›å¾ªç¯ä¸Šè¿°æ“ä½œï¼Œç›´è‡³å¾—åˆ°æœ€åçš„åºåˆ—ã€‚
### æˆ‘çš„ç¥å¥‡è„‘å›è·¯
ğŸ“è®¾ç½®i,jä½œä¸ºç§»åŠ¨çš„æŒ‡é’ˆï¼Œæ¯æ¬¡é€‰å–ä¸¤ä¸ªç›¸é‚»çš„åºåˆ—ï¼ˆæ³¨æ„æ§åˆ¶i,jçš„é€’å¢çŠ¶æ€ï¼‰ï¼Œç„¶åä»å·¦å¾€å³åœ°ç§»åŠ¨i,jæŒ‡é’ˆã€‚
ğŸŒ°ç»è¿‡gptä¿®æ­£çš„ç‰ˆæœ¬ï¼š
```c
void merge_pass( ElementType list[], ElementType sorted[], int N, int length )
{
    int i, j;

    void sort_once(ElementType list[], ElementType sorted[], int left, int mid, int right)
    {
        int i = left, j = mid, k = left;
        
        while (i < mid && j < right) {
            if (list[i] <= list[j]) {
                sorted[k++] = list[i++];
            } else {
                sorted[k++] = list[j++];
            }
        }
        while (i < mid) 
            sorted[k++] = list[i++];
        while (j < right) 
            sorted[k++] = list[j++];
    }

    for (i = 0; i < N; i += 2 * length) {
        int left = i;
        int mid = (i + length < N) ? i + length : N;
        int right = (i + 2 * length < N) ? i + 2 * length : N;
        sort_once(list, sorted, left, mid, right);
    }
}
```

## ç¼–ç¨‹
- è¦æ±‚ï¼š
	é¢˜ç›®å›´ç»•æ’å…¥æ’åºå’Œå †æ’åºçš„é—®é¢˜å±•å¼€ã€‚å¹¶ä¸”è¦æ±‚å¯¹ä¸€ä¸ªç»™å®šçš„åºåˆ—æŒ‰ç…§ä»å°åˆ°å¤§æ’åºï¼›
	æˆ‘ä»¬æ³¨æ„åˆ°ï¼Œæ’å…¥æ’åºçš„é€»è¾‘æ˜¯ï¼šä¾æ¬¡æŠ½å–ç»™å®šçš„åºåˆ—çš„å…ƒç´ ï¼Œæ‰¾åˆ°åˆé€‚çš„ä½ç½®ï¼Œå› æ­¤æ¯ä¸€æ­¥å¾ªç¯æ€»æ˜¯<mark style="background: #FFF3A3A6;">ä»å‰å¼€å§‹æœ‰åº</mark>ã€‚å¦ä¸€æ–¹é¢ï¼Œå¯¹äº**ä»å°åˆ°å¤§**çš„å †æ’åºï¼Œæˆ‘ä»¬éœ€è¦æ„é€ <mark style="background: #ADCCFFA6;">æœ€å¤§å †</mark>ï¼Œå¹¶ä¸”æ¯æ¬¡å–ç”¨æœ€å¤§å…ƒç´ æ”¾åˆ°æ•°ç»„æœªæ’åºéƒ¨åˆ†çš„æœ€æœ«ç«¯ï¼›å› æ­¤ï¼Œæ¯ä¸€æ­¥å¾ªç¯æ€»æ˜¯ä»<mark style="background: #FFF3A3A6;">åé¢ä¾æ¬¡å‘å‰æœ‰åº</mark>ï¼
	é¢˜ç›®å°†ç»™å‡ºå¾…æ’åºçš„åºåˆ—ï¼Œä»¥åŠæ’åºè¿‡ç¨‹ä¸­æŸä¸€æ­¥çš„ç»“æœã€‚è¦æ±‚æˆ‘ä»¬æ®æ­¤åˆ¤æ–­ä½¿ç”¨äº†ä¸Šè¿°å“ªä¸€ç§æ’åºæ–¹æ³•ï¼Œå¹¶ä¸”ç»™å‡ºç”¨è¯¥æ–¹æ³•ä¸‹ä¸€æ­¥å¾ªç¯å¾—åˆ°çš„åºåˆ—ç»“æœã€‚
- åˆ†æï¼š
	- é¢˜ç›®çš„è§£å†³æ˜¾ç„¶åˆ†ä¸ºä¸¤éƒ¨åˆ†â€”â€”â‘ åˆ¤æ–­æ‰€ç”¨çš„æ’åºæ–¹å¼ï¼›â‘¡æ ¹æ®è¯¥æ–¹å¼è¿›ä¸€æ­¥æ’åº
	- ç¬¬ä¸€æ­¥æ˜¯å®¹æ˜“çš„ï¼Œæˆ‘ä»¬åªè¦åˆ¤æ–­å‰å‡ ä¸ªæ•°å­—å’Œåå‡ ä¸ªæ•°å­—æ˜¯å¦æ»¡è¶³æ’åºå…³ç³»å³å¯
	- å¯¹äºç¬¬äºŒæ­¥ï¼Œæˆ‘ä»¬éœ€è¦å¦å¤–å†™ä¸¤ä»½å‡½æ•°ï¼Œæ ¹æ®é€‰æ‹©è°ƒç”¨å¯¹åº”çš„ç®—æ³•
- ğŸ§é—®é¢˜ï¼š
	- å¦‚ä½•åˆ¤æ–­æ–¹å¼
		- å¦‚æœç»™å®šçš„åŸåºåˆ—æœ¬èº«å°±æ˜¯éƒ¨åˆ†æœ‰åºï¼ˆå¼€å¤´æˆ–è€…ç»“å°¾ï¼‰ï¼Œé‚£ä¹ˆä¸èƒ½ç®€å•åœ°åˆ¤æ–­
### è§£ç­”ï¼š
ğŸŒ°:
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

// åˆ†ææ’åºæ–¹å¼ï¼šæ’å…¥æ’åºè¿”å›1ï¼Œå †æ’åºè¿”å›2
int judgeSort(int* arr, int* judge, int size) {
    int i, count = 0;

    // æ‰¾åˆ°éƒ¨åˆ†æœ‰åºçš„æœ€åä¸€ä¸ªå…ƒç´ ä½ç½®
    while (count < size - 1 && judge[count] <= judge[count + 1]) {
        count++;
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºæ’å…¥æ’åº
    for (i = count + 1; i < size; i++) {
        if (judge[i] != arr[i]) {
            return 2; // ä¸æ»¡è¶³æ’å…¥æ’åºæ¡ä»¶ï¼Œåˆ™ä¸ºå †æ’åº
        }
    }
    return 1; // æ»¡è¶³æ’å…¥æ’åºæ¡ä»¶
}

void insertionSort(int* seq, int* sort, int length) {
    int count = 0;
    while (count < length - 1 && sort[count] <= sort[count + 1]) {
        count++;
    }
    int sortNum = sort[count + 1];
    int i;
    for (i = count + 1; i > 0 && sort[i - 1] > sortNum; i--) {
        sort[i] = sort[i - 1];
    }
    sort[i] = sortNum;

    for (int i = 0; i < length; i++) {
        if (i == 0)
            printf("%d", sort[i]);
        else
            printf(" %d", sort[i]);
    }
    printf("\n");
}

void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

void maxHeapify(int* arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }

    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    if (largest != i) {
        swap(&arr[i], &arr[largest]);
        maxHeapify(arr, n, largest);
    }
}

void buildMaxHeap(int* arr, int n) {
    for (int i = n / 2 - 1; i >= 0; i--) {
        maxHeapify(arr, n, i);
    }
}

int findMax(int* seq, int* checkedId, int size) {
    int max = -1, maxId = -1;
    for (int i = 0; i < size; i++) {
        if (checkedId[i] == 0 && seq[i] > max) {
            max = seq[i];
            maxId = i;
        }
    }
    if (maxId != -1)
        checkedId[maxId] = 1;
    return max;
}

void heapSort(int* seq, int* sort, int size) {
    int count = size - 1;

    // æ‰¾åˆ°éƒ¨åˆ†æœ‰åºçš„æœ€åä¸€ä¸ªå…ƒç´ ä½ç½®
    while (count > 0 && sort[count] >= sort[count - 1]) {
        count--;
    }

    // ç¡®ä¿åªå¯¹æœªæ’åºéƒ¨åˆ†è¿›è¡Œå †åŒ–
    buildMaxHeap(sort, count + 1);

    // äº¤æ¢å †é¡¶å…ƒç´ å’Œæœ€åä¸€ä¸ªæœªæ’åºçš„å…ƒç´ 
    swap(&sort[0], &sort[count]);

    // è°ƒæ•´å †
    maxHeapify(sort, count, 0);

    // è¾“å‡ºç»“æœ
    for (int i = 0; i < size; i++) {
        if (i == 0)
            printf("%d", sort[i]);
        else
            printf(" %d", sort[i]);
    }
    printf("\n");
}


int main() {
    int length, method;
    int* sequence;
    int* partialSorted;
    scanf("%d", &length);
    sequence = (int*)malloc(sizeof(int) * length);
    partialSorted = (int*)malloc(sizeof(int) * length);

    // è¯»å…¥åŸå§‹åºåˆ—ä¸éƒ¨åˆ†æ’åºåºåˆ—
    for (int i = 0; i < length; i++)
        scanf("%d", &sequence[i]);
    for (int i = 0; i < length; i++)
        scanf("%d", &partialSorted[i]);

    // ç”±ç¬¬äºŒä»½åºåˆ—åˆ†æå¯¹åº”çš„æ’åºæ–¹å¼ï¼šæœ‰åºæ„å»ºçš„æ–¹å‘
    method = judgeSort(sequence, partialSorted, length);
    switch (method) {
    case 1:
        printf("Insertion Sort\n");
        insertionSort(sequence, partialSorted, length);
        break;
    case 2:
        printf("Heap Sort\n");
        heapSort(sequence, partialSorted, length);
        break;
    }

    free(sequence);
    free(partialSorted);
    return 0;
}

```
# HW13
## ä¼˜å…ˆå¤„ç†è¾ƒå°å­æ•°ç»„çš„å¿«æ’
- ğŸŒ°æè¿°ï¼š
	***During the sorting, processing every element which is not yet at its final position is called a "run". To sort a list of integers using quick sort, it may reduce the total number of recursions by processing the small partion first in each run.***
- âœ…è§£é‡Šï¼š![Pasted image 20240529185041.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240529185041.png)
## é“¾è¡¨ç»“æ„å¯¹æ’åºçš„å½±å“
- æè¿°ï¼šé‡‡ç”¨é“¾è¡¨è€Œéæ•°ç»„çš„æ•°æ®ç»“æ„ï¼Œæ¥è¿›è¡Œæ’åºæ—¶ï¼Œç®—æ³•ä¼šå—åˆ°ä»€ä¹ˆå½±å“å‘¢ï¼Ÿ
- åˆ†æï¼š
	- <mark style="background: #FFF3A3A6;">æ’å…¥ç®—æ³•å°†å¾—åˆ°ä¼˜åŒ–</mark>ï¼šè¿™æ˜¯æ¯æ¬¡é€‰æ‹©åˆé€‚çš„ä½ç½®å¯¹æœªæ’åºçš„å…ƒç´ è¿›è¡Œ**æ’å…¥**ï¼Œè¿™ä¸€æ“ä½œå¥‘åˆé“¾è¡¨æ–¹ä¾¿æ’å…¥çš„ç‰¹æ€§ï¼›
	- <mark style="background: #FFF3A3A6;">å¸Œå°”æ’åºä¼šé™ä½æ•ˆç‡</mark>ï¼šè¿™æ˜¯å› ä¸ºè™½ç„¶å¸Œå°”æ’åºæ˜¯åœ¨æ’å…¥æ’åºçš„åŸºç¡€ä¸Šè¿›è¡Œçš„ï¼Œä½†æ˜¯æ˜¯é€‰æ‹©`gap`å¯¹ä¸è¿ç»­çš„éƒ¨åˆ†è¿›è¡Œéƒ¨åˆ†æ’åºã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œé“¾è¡¨éœ€è¦å¤šæ¬¡ç§»åŠ¨ï¼Œæ‰èƒ½æ¯”è¾ƒå¯¹åº”çš„æ•°æ®ã€‚å› æ­¤æ•ˆç‡ä½ä¸‹
	- <mark style="background: #FFF3A3A6;">å †æ’åºä¼šé™ä½æ•ˆç‡</mark>ï¼šè¿™æ˜¯å› ä¸ºæ¶‰åŠåˆ°äº†å †é¡¶å…ƒç´ ä¸æ•°ç»„æœ«å°¾å…ƒç´ çš„**äº¤æ¢**ï¼Œæ­¤åè¦è¿›ä¸€æ­¥å¯¹**éç›¸é‚»çš„å…ƒç´ è¿›è¡Œæ¯”è¾ƒ**æ¥ç»´æŒå †çš„æ€§è´¨ã€‚
	- <mark style="background: #FFF3A3A6;">å†’æ³¡æ’åºå°†æ˜¯é«˜æ•ˆ</mark>çš„ï¼šè¿™æ˜¯å› ä¸ºä¾æ¬¡æ¯”è¾ƒç›¸é‚»çš„å…ƒç´ å¤§å°ï¼Œå¦‚æœé¡ºåºå¼‚å¸¸å¯ä»¥ç›´æ¥äº¤æ¢æ•°æ®åŸŸçš„å€¼ã€‚
- ç»¼ä¸Šï¼Œ**æ’å…¥**æ’åºå’Œ**å†’æ³¡**æ’åºå°†ä¼šåœ¨é“¾è¡¨æ•°æ®ç»“æ„çš„æ’åºä¸­é«˜æ•ˆè¡¨ç°ã€‚
## å‚»é€¼é¢˜
![Pasted image 20240529201222.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240529201222.png)