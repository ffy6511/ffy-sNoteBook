---
{"dg-publish":true,"permalink":"/obsidian///xlab///","created":"2024-07-02T14:45:33.332+08:00","updated":"2024-09-08T15:25:05.453+08:00"}
---

# 基础概念
---
DOM
	文档对象模型,是HTML和XML文档的编程接口。它将网页表示为一个树形结构。

Fetch API
	现代浏览器提供的用于网络请求的接口

JSON
	 一种轻量级的数据交换格式,易于人阅读和编写,也易于机器解析和生成。

# 流程分析
>重点关注JS与后端的交互

## CSS网页
>https://neumorphism.io/#e6eef4

>    justify-content:space-between; 可以使得元素沿主轴分布，且分别为左对齐和右对齐
---
## 路由器
>将前端js当中的url与后端负责响应的handler.go函数相互联系;
>	根据请求的 URL 调用相应的处理程序

🌰查询评论：

①后端中的router
```go
    router.HandleFunc("/comment/get", GetComments).Methods("GET")
```
表示将相对路径为`/comment/get`的`URL`请求用GetComments函数进行响应，并且指定请求方式为GET

②前端的fetchComments
```js
  //获取评论
    async function fetchComments(page) {
        const response = await fetch(`http://localhost:8080/comment/get?page=${page}&size=${pageSize}`);

        const data = await response.json();
        return data.data;
    }
```
可以看到对应的URL

③GETComments
```go
func GetComments(w http.ResponseWriter, r *http.Request) {
	// 从请求中获取分页参数
	page, _ := strconv.Atoi(r.URL.Query().Get("page"))
	size, _ := strconv.Atoi(r.URL.Query().Get("size"))

	// 设置默认值
	if page < 1 {
		page = 1
	}
	if size < 1 {
		size = 10
	}

	var comments []Comment
	DB.Offset((page - 1) * size).Limit(size).Find(&comments) // 分页查询评论

	var total int64
	DB.Model(&Comment{}).Count(&total) // 获取评论总数

	response := Response{
		Code: 0,
		Msg:  "success",
		Data: map[string]interface{}{
			"total":    total,
			"comments": comments,
		},
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}
```

❓相对何处的路径？
	`main.go`中确定了主路径
```go
func main() {
    Init()
    router := NewRouter()
    router.HandleFunc("/favicon.ico", func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusNoContent)
    })
    // 设置中间件
    corsRouter := handlers.CORS(
        handlers.AllowedOrigins([]string{"http://localhost:8081"}),            // 允许来自http://localhost:8081的请求
        handlers.AllowedMethods([]string{"GET", "POST", "DELETE", "OPTIONS"}), // 允许的HTTP方法
        handlers.AllowedHeaders([]string{"Content-Type"}),                     // 允许的Header
    )(router)

    log.Println("Server started at :8080")
    log.Fatal(http.ListenAndServe(":8080", corsRouter))
}
```
此处最后一行指定服务器监听的端口是8080，也就是`http://localhost:8080`

---
## 初始化和事件监听
```js
// 等待DOM完全加载后执行代码
document.addEventListener('DOMContentLoaded', () => {
    // 获取页面上的各个元素
    const commentForm = document.getElementById('comment-form');
    const commentList = document.getElementById('comment-list');
    const prevButton = document.getElementById('prev-page');
    const nextButton = document.getElementById('next-page');
    const pageInfo = document.getElementById('page-info');

    // 初始化分页相关变量
    let currentPage = 1;
    let totalPages = 1;
    const pageSize = 10; // 每页显示的评论数

    // ... 其他代码 ...

    // 初始加载评论
    loadComments();
});

```
- 等待DOM加载完成后执行
- 获取页面上的各个重要元素
- 调用`loadComments()`函数加载初始评论

## 提交新评论
```js
commentForm.addEventListener('submit', async (e) => {
    e.preventDefault(); // 阻止表单默认提交行为

    // 获取用户名和评论内容
    const usernameInput = document.getElementById('username');
    const commentContentInput = document.getElementById('comment-content');
    // 去除首尾空格
    const username = usernameInput.value.trim();
    const content = commentContentInput.value.trim();

    if (username && content) { // 如果用户名和内容都不为空
        // 调用addComment函数添加新评论
        const newComment = await addComment({ name: username, content: content });
        if (newComment) {
            // 如果成功添加评论
            addCommentToDOM(newComment); // 将新评论添加到DOM
            commentContentInput.value = ''; // 清空评论内容输入框
            commentContentInput.focus(); // 将焦点放回评论输入框
            currentPage = 1; // 重置到第一页
            loadComments(); // 重新加载评论列表
        } else {
            commentContentInput.focus(); // 如果添加失败,保持焦点在评论输入框
        }
    }
});
```
- 监听评论表单的提交事件
- 提交新评论时,它会阻止表单的默认提交行为,获取用户输入的用户名和评论内容,
- 调用`addComment`函数将新评论发送到服务器。

## 添加评论到服务器
```js
// 添加评论请求
async function addComment(comment) {
    // 使用Fetch API发送POST请求到服务器
    const response = await fetch('http://localhost:8080/comment/add', {
        method: 'POST', // 使用POST方法
        headers: {
            'Content-Type': 'application/json', // 设置内容类型为JSON
        },
        body: JSON.stringify(comment), // 将评论对象转换为JSON字符串
    });
    const data = await response.json(); // 解析服务器返回的JSON响应
    return data.data; // 返回服务器返回的数据
}
```
- 使用Fetch API向服务器发送POST请求
- 将评论对象转换为JSON字符串，并在请求头中设置内容类型为JSON
- 服务器处理请求后,函数解析返回的JSON响应并返回数据

❓两个data的区别
1. 第一个data表示变量名，用fetch请求的返回值作为值
2. 第二个data是返回值所包含的对象：
```go
type Response struct {
    Code int         `json:"code"`
    Msg  string      `json:"msg"`
    Data interface{} `json:"data"`
}
```
在后端的结构体定义当中，返回的Data的json形式中被称为data

## 加载评论
```js
async function loadComments() {
    // 从服务器获取评论
    const { comments, total } = await fetchComments(currentPage);
    commentList.innerHTML = ''; // 清空当前评论列表
    comments.forEach(comment => addCommentToDOM(comment)); // 将每条评论添加到DOM

    // 更新分页信息
    totalPages = Math.max(1, Math.ceil(total / pageSize));
    pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;

    // 更新分页按钮状态
    prevButton.disabled = currentPage === 1;
    nextButton.disabled = currentPage >= totalPages;
}

async function fetchComments(page) {
    // 使用Fetch API从服务器获取评论
    const response = await fetch(`http://localhost:8080/comment/get?page=${page}&size=${pageSize}`);
    const data = await response.json();
    return data.data;
}
```
- 调用`fetchComments`函数获取特定页的评论
- `commentList.innerHTML = ''`  将清空当前评论列表
- 将新的评论添加到DOM中

## 删除评论
```js
async function deleteComment(id) {
    // 使用Fetch API发送POST请求删除评论
    await fetch(`http://localhost:8080/comment/delete?id=${id}`, {
        method: 'POST',
    });
}

function addCommentToDOM(comment) {
    // ... 创建评论元素的代码 ...

    const deleteButton = document.createElement('button');
    deleteButton.textContent = 'Delete';
    deleteButton.addEventListener('click', async () => {
        await deleteComment(comment.id); // 调用deleteComment函数删除评论
        commentList.removeChild(commentItem); // 从DOM中移除评论元素
    });

    // ... 将删除按钮添加到评论元素的代码 ...
}
```
- 向服务器发送POST请求来删除特定ID的评论
- 


# 交互分析
---
## 查询评论

1. `fetchComments`用于向后端发送查询对应页数评论的请求，如果成功则返回对应的数据
2. `loadComments`将当前页数`currentPage`作为`fetchComments`的参数,将返回的数据遍历调用`addCommentToDOM`来可视化
3. 所以主体是`load`，它将调用`fetch`与`add`函数，分别向后端发送请求 以及 可视化
```js
async function fetchComments(page) {
    const response = await fetch(`http://localhost:8080/comment/get?page=${page}&size=${pageSize}`);
    const data = await response.json();
    return data.data;
}
```

```js
 async function loadComments() {
        const { comments, total } = await fetchComments(currentPage);
        commentList.innerHTML = ''; // 清空评论列表
        comments.forEach(comment => addCommentToDOM(comment)); // 添加新评论

        totalPages = Math.max(1, Math.ceil(total / pageSize));
        pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;

        prevButton.disabled = currentPage === 1;
        nextButton.disabled = currentPage >= totalPages;
    }
```

```js
  // 将评论添加到DOM中
    function addCommentToDOM(comment) {
	    //创建一个列表类的元素
        const commentItem = document.createElement('li');
        //将数据的id赋值给该元素的HTML属性id
        commentItem.dataset.id = comment.id;

        const commentText = document.createElement('span');
        
        //用`并将数据的类型赋值给文本内容
        commentText.textContent = `${comment.name}: ${comment.content}`;

		//对于每条评论，根据id设置对饮的删除按钮
        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.addEventListener('click', async () => {
            await deleteComment(comment.id);
            commentList.removeChild(commentItem);
        });

        commentItem.appendChild(commentText);
        commentItem.appendChild(deleteButton);

        commentList.insertBefore(commentItem, commentList.firstChild); // 添加新评论到列表的开头
    }
```

```go
func GetComments(w http.ResponseWriter, r *http.Request) {
    // 从请求中获取分页参数
    page, _ := strconv.Atoi(r.URL.Query().Get("page"))
    size, _ := strconv.Atoi(r.URL.Query().Get("size"))

    // 设置默认值
    if page < 1 {
        page = 1
    }
    if size < 1 {
        size = 10
    }

    var comments []Comment
    DB.Offset((page - 1) * size).Limit(size).Find(&comments) // 分页查询评论
    //Offset 设置了查询的偏移量，表示偏移(page-1）*size个数据，保证正确显示currentPage页的评论
    //Limit(size)确保最多显示size得评论个数，防止后面的评论同时显示
    //Findj将查询的数据结果赋值给了上面的结构体comment类型的数组

    var total int64
    DB.Model(&Comment{}).Count(&total) // 获取评论总数，存储到total当中

    response := Response{
        Code: 0,
        Msg:  "success",
        Data: map[string]interface{}{
            "total":    total,
            "comments": comments,
        },
    }
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

```
## 添加评论

## 删除评论
```js
async function deleteComment(id) {
    await fetch(`http://localhost:8080/comment/delete?id=${id}`, {
        method: 'POST',
    });
}
```
>前端通过 `fetch` 函数发送 POST 请求到 `/comment/delete` 端点，URL 中包含要删除的评论 ID

```go
func DeleteComment(w http.ResponseWriter, r *http.Request) {
    idStr := r.URL.Query().Get("id")  //从 URL 查询参数中提取评论 ID。
    id, err := strconv.Atoi(idStr)    //在数据库中查找对应 ID 的评论,找不到时err返回真值
    if err != nil {
        http.Error(w, "Invalid ID", http.StatusBadRequest)
        return
    }

    var comment Comment // Comment类型的变量comment

	//使用了数据库操作，尝试从数据库中获取特定 ID 的评论数据
    if DB.First(&comment, id).Error != nil { 
        http.Error(w, "Comment not found", http.StatusNotFound)
        return
    }
	//成功删除则构造一个表示操作成功的 JSON 响应，并返回前端
    DB.Delete(&comment)

    response := Response{
        Code: 0,
        Msg:  "success",
        Data: nil,
    }
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}
```

## 分页转换
