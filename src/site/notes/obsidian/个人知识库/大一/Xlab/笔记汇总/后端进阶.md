---
{"dg-publish":true,"permalink":"/obsidian///xlab///","created":"2024-08-26T12:03:57.119+08:00","updated":"2024-09-08T15:25:05.479+08:00"}
---

# 推荐工具
## drizzle
>https://orm.drizzle.team/docs/rqb

## formik
1.44
## SWR
>https://nextjs.org/docs/pages/building-your-application/data-fetching/client-side

在客户端获取数据

# 改进方向
## tailwindcss
- 实现暗黑模式
>https://tailwindcss.com/docs/dark-mode

- 注册时的密码确认
- 进入chat的hello效果
- cookie的设置
- 时间显示
- 最后一条消息
- 退出与注销的区别


```ts
import React from 'react';
import { Button, message, Space } from 'antd';

const App: React.FC = () => {
  const [messageApi, contextHolder] = message.useMessage();

  const success = () => {
    messageApi.open({
      type: 'success',
      content: 'This is a success message',
    });
  };

  const error = () => {
    messageApi.open({
      type: 'error',
      content: 'This is an error message',
    });
  };

  const warning = () => {
    messageApi.open({
      type: 'warning',
      content: 'This is a warning message',
    });
  };

  return (
    <>
      {contextHolder}
      <Space>
        <Button onClick={success}>Success</Button>
        <Button onClick={error}>Error</Button>
        <Button onClick={warning}>Warning</Button>
      </Space>
    </>
  );
};

export default App;
```

链接：
```ts
import React from 'react';
import { Button, Flex } from 'antd';

const App: React.FC = () => (
  <Flex gap="small" wrap>
    <Button type="primary">Primary Button</Button>
    <Button>Default Button</Button>
    <Button type="dashed">Dashed Button</Button>
    <Button type="text">Text Button</Button>
    <Button type="link">Link Button</Button>
  </Flex>
);

export default App;
```

```ts
import React from 'react';
import { Alert } from 'antd';

const App: React.FC = () => (
  <>
    <Alert message="Success Tips" type="success" showIcon />
    <br />
    <Alert message="Informational Notes" type="info" showIcon />
    <br />
    <Alert message="Warning" type="warning" showIcon closable />
    <br />
    <Alert message="Error" type="error" showIcon />
    <br />
    <Alert
      message="Success Tips"
      description="Detailed description and advice about successful copywriting."
      type="success"
      showIcon
    />
    <br />
    <Alert
      message="Informational Notes"
      description="Additional description and information about copywriting."
      type="info"
      showIcon
    />
    <br />
    <Alert
      message="Warning"
      description="This is a warning notice about copywriting."
      type="warning"
      showIcon
      closable
    />
    <br />
    <Alert
      message="Error"
      description="This is an error message about copywriting."
      type="error"
      showIcon
    />
  </>
);

export default App;
```
# 知识补充
❓**初始化数据库**
- `.env`等文件中给出password以及database
- 根据db/schema的表的结构，确保存在对应的表
	- 可以先运行`npx drizzle-kit generate`来创建文件，然后复制其中代码



## tRPC
> 前端通过创建 tRPC 客户端并将其导入到需要的组件中，可以直接在组件中发送请求到后端的 tRPC 路由器上。这种方式确保了前后端通信的类型安全和一致性

### 1. **创建 tRPC 客户端**

首先，需要在前端创建一个 tRPC 客户端，这个客户端用于在前端调用后端的 API。

假设在 `server` 目录中定义了一个 tRPC 路由器，`AppRouter` 包含了所有想要暴露给前端的 API。

**后端的 tRPC 路由器 (`server/trpcRouter.ts`)：**

```typescript
// server/trpcRouter.ts
import { router, publicProcedure } from '@trpc/server';
import { z } from 'zod';

// 定义一个简单的路由器，包含一个获取用户信息的API
export const appRouter = router({
  getUser: publicProcedure
    .input(z.object({ userId: z.string() }))
    .query(({ input }) => {
      // 假设这里从数据库获取用户信息
      return { id: input.userId, name: "John Doe" };
    }),
});

// 导出路由器的类型以供前端使用
export type AppRouter = typeof appRouter;
```

### 2. **在前端创建 tRPC 客户端**

在前端，你需要根据后端的 `AppRouter` 类型创建一个 tRPC 客户端。这通常在一个独立的文件中完成，比如 `trpc.ts`。

**前端的 tRPC 客户端 (`app/trpc.ts`)：**

```typescript
// app/trpc.ts
import { createTRPCReact } from '@trpc/react';
import type { AppRouter } from '../server/trpcRouter'; // 导入后端的类型定义

// 基于后端的 AppRouter 类型创建 tRPC 客户端
export const trpc = createTRPCReact<AppRouter>();
```

### 3. **在组件中使用 tRPC 客户端**

**React 组件中使用 tRPC (`app/components/UserProfile.tsx`)：**

```typescript
// app/components/UserProfile.tsx
import React from 'react';
import { trpc } from '../trpc'; // 导入 tRPC 客户端

const UserProfile = ({ userId }: { userId: string }) => {
  // 使用 tRPC 客户端调用 getUser API
  const { data, isLoading, error } = trpc.getUser.useQuery({ userId });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <h1>{data?.name}</h1>
      <p>ID: {data?.id}</p>
    </div>
  );
};

export default UserProfile;
```

### 4. **解释**

- **导入 tRPC 客户端**: 在 `UserProfile` 组件中，首先导入了在 `trpc.ts` 中定义的 tRPC 客户端 `trpc`。

- **调用 API**: 使用 `trpc.getUser.useQuery` 来调用后端的 `getUser` API。这个 API 需要一个 `userId` 作为输入参数，并返回用户信息。

- **自动类型检查**: 因为 tRPC 客户端是基于后端的 `AppRouter` 类型创建的，`trpc.getUser.useQuery` 会自动检查 `userId` 参数的类型，并确保返回的数据与后端的定义一致。这种类型安全确保了前后端的一致性，并减少了因类型不匹配导致的错误。

- **状态管理**: `useQuery` 返回的对象包含 `data`、`isLoading`、`error` 等状态信息，帮助你轻松管理异步请求的状态，并在 UI 中展示合适的信息。

### 5. **工作流程总结**

1. **后端定义 API**: 在后端的 tRPC 路由器中定义 API，并导出路由器的类型。

2. **前端创建客户端**: 在前端基于后端的路由器类型创建 tRPC 客户端。

3. **组件中调用 API**: 在需要调用后端 API 的 React 组件中，导入 tRPC 客户端并使用相应的 hook（如 `useQuery` 或 `useMutation`）调用 API。
## next.js的路由
### 自动路由
- 任意文件夹的pages子文件夹内的文件将被路由
🌰：
	src /pages /about.js 或者 src /pages /about/ index.js 将会自动通过 **/about** 访问

- 可以通过next.js提供的link 或 router组件在页面间跳转
🌰：
![Pasted image 20240828222809.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240828222809.png)

### 动态路由
- 通过使用方括号 `[]`，可以在 `pages` 目录中定义动态路由。文件名中的变量部分将作为路由参数传递给页面组件。
- 例如，`pages/blog/[slug].js` 对应 `/blog/:slug`，其中 `slug` 是一个动态参数
```js
// pages/blog/[slug].js
import { useRouter } from 'next/router';

const Post = () => {
  const router = useRouter();
  const { slug } = router.query;

  return <p>Post: {slug}</p>;
};

export default Post;
```
>访问 `/blog/my-first-post`，页面将显示 `Post: my-first-post`。

### API路由
任何在 `pages/api` 中的文件都会成为一个 API 路由，并在服务器端执行
🌰：`pages/api/hello.js` 对应 `/api/hello`，用于处理 HTTP 请求并返回 JSON 响应
```js
// pages/api/hello.js
export default function handler(req, res) {
  res.status(200).json({ message: 'Hello, World!' });
}
```

### 📝:
假设文件夹结构如下：
```
my-next-app/
├── pages/
│   ├── index.js
│   ├── about.js
│   ├── blog/
│   │   ├── index.js
│   │   └── [slug].js
│   └── api/
│       └── hello.js
```
- `/` 会加载 `index.js` 中的内容。
- `/about` 会加载 `about.js` 中的内容。
- `/blog` 会加载 `blog/index.js` 中的内容。
- `/blog/some-post` 会加载 `blog/[slug].js`，并将 `slug` 设置为 `some-post`。
- `/api/hello` 是一个 API 路由，返回 JSON 响应。

## next下的页面跳转
### link

🌰:
```tsx
// app/page.js  
import Link from 'next/link';  
import Login from './user/Login/Login';  
  
function JumpToChat() {  
    return (  
        <div>  
            <Link href="/chatroom">  
                Go to Chat
            </Link>  
            <Login />  
        </div>  
    );  
}  
  
export default JumpToChat;  
```
>作为page

```tsx
// app/page.js    
import Login from './user/Login/Login';  
  
export default function Page() {  
    return <Login />;
}


```

### useRouter
>是一个 React Hook,可以方便地获取路由信息、执行路由跳转等操作

#### 🌰：
```js
import { useRouter } from 'next/router';

function MyComponent() {
  const router = useRouter();

  const handleClick = () => {
    // 跳转到 /about 页面
    router.push('/about');
  };

  return (
    <div>
      <p>Current Route: {router.pathname}</p>
      <button onClick={handleClick}>Go to About</button>
    </div>
  );
}

export default MyComponent;
```

#### 特点
- **仅限于函数组件**: `useRouter` 只能在函数组件中使用，这是因为它是一个 React Hook。
- **访问路由信息**: 通过 `router` 对象，可以获取当前路径 (`pathname`)、查询参数 (`query`)、路由路径 (`asPath`) 等。
- **路由跳转**: `useRouter` 提供了 `push`、`replace` 等方法，用于执行路由跳转。

### withRouter
>一个高阶组件,可以将路由对象作为 `props` 传递给任意组件。

#### 🌰：
```js
import { withRouter } from 'next/router';

class MyComponent extends React.Component {
  handleClick = () => {
    const { router } = this.props;
    // 跳转到 /about 页面
    router.push('/about');
  };

  render() {
    const { router } = this.props;
    return (
      <div>
        <p>Current Route: {router.pathname}</p>
        <button onClick={this.handleClick}>Go to About</button>
      </div>
    );
  }
}

export default withRouter(MyComponent);
```
>不建议用在函数组件


## 路由的实例说明

后端：设置函数并路由到一个AppRouter整体（并导出类型，为前端的调用服务）
>![Pasted image 20240828224436.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240828224436.png)

前后端之间：
>![Pasted image 20240828224455.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240828224455.png)

前端的调用：
>![Pasted image 20240828224336.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240828224336.png)
>结合`next.js的路由/API路由`内容可知，将 `tRPC` 路由器暴露为 API 端点.
>使 `tRPC` 路由器在 `http://localhost:3000/api/trpc` 这个路径下可用。每一个定义在 `appRouter` 中的路由都会对应一个 URL 路径（例如 `auth.login` 对应 `/api/trpc/auth.login`）。
>![Pasted image 20240828224606.png](/img/user/obsidian/%E5%9B%BE%E7%89%87%E5%AF%84%E5%AD%98%E5%99%A8/Pasted%20image%2020240828224606.png)为例（此处行8,13）
>


## tRPC上下文
- 含义：
	“上下文”指的是一种在组件树中传递数据的方式，使得组件可以共享一些全局数据，而不需要通过一层一层的props传递。tRPC上下文是一个专门用于管理和提供tRPC相关功能和数据的上下文

>https://trpc.io/docs/server/context#defining-the-context-type


